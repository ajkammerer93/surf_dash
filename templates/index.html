<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Surf Forecast</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><path d='M2 20 Q8 10 14 18 Q20 26 26 16 Q29 11 30 12' fill='none' stroke='%2344ff88' stroke-width='3' stroke-linecap='round'/><path d='M2 24 Q8 16 14 22 Q20 28 26 20 Q29 16 30 17' fill='none' stroke='%233388ff' stroke-width='2.5' stroke-linecap='round'/></svg>">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <!-- Leaflet Velocity CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-velocity@2.1.4/dist/leaflet-velocity.css" />
    <!-- GridStack CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@10/dist/gridstack.min.css" />
    <style>
        /* === Design Tokens === */
        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --border: #2a2a2a;
            --text: #e8e8e8;
            --text-dim: #888;
            --text-muted: #666;
            --accent: #fff;
            --status-live: #44ff88;
            --status-warning: #ffaa00;
            --status-error: #ff4444;
            --font-body: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Consolas', monospace;
        }

        /* === Reset & Base === */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-body);
            font-size: 12px;
            line-height: 1.4;
            -webkit-font-smoothing: antialiased;
        }

        /* === Scrollbar === */
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        /* === Header === */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            z-index: 1000;
            gap: 12px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--accent);
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background 0.15s;
            min-width: 0;
            overflow: hidden;
        }

        .header-center:hover { background: rgba(255,255,255,0.05); }

        .header-location {
            font-size: 11px;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .header-coords {
            font-size: 10px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .header-clock {
            font-size: 11px;
            color: var(--text-dim);
            font-variant-numeric: tabular-nums;
        }

        .header-version {
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border: 1px solid var(--border);
            border-radius: 2px;
        }

        .header-btn {
            font-family: var(--font-body);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 10px;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .header-btn:hover {
            color: var(--text);
            border-color: var(--text-muted);
            background: rgba(255,255,255,0.03);
        }

        /* === GridStack Dashboard === */
        .grid-stack {
            margin-top: 40px;
        }

        .grid-stack-item-content {
            background: var(--surface);
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .grid-stack-item-content .panel {
            display: flex;
            flex-direction: column;
            min-width: 0;
            height: 100%;
            overflow: hidden;
        }

        /* Keep dragging widgets below the header */
        .grid-stack-item.ui-draggable-dragging {
            z-index: 900 !important;
        }

        /* Placeholder styling for dark theme */
        .grid-stack-placeholder > .placeholder-content {
            background: rgba(255, 255, 255, 0.03) !important;
            border: 1px dashed var(--text-muted) !important;
        }

        /* Resize handle styling */
        .grid-stack-item > .ui-resizable-se {
            filter: invert(1) brightness(0.5);
        }

        /* Fullscreen wrapper on grid-stack-item */
        .grid-stack-item.panel-fullscreen-wrapper {
            position: fixed !important;
            inset: 0 !important;
            z-index: 1500 !important;
            width: 100% !important;
            height: 100% !important;
        }

        .grid-stack-item.panel-fullscreen-wrapper .panel-content {
            flex: 1;
            overflow: auto;
        }

        .grid-stack-item.panel-fullscreen-wrapper .map-container {
            height: 100% !important;
        }

        .grid-stack-item.panel-fullscreen-wrapper .chart-wrap {
            height: calc(100vh - 40px);
        }

        .grid-stack-item.panel-fullscreen-wrapper .panel-content {
            max-height: none !important;
        }

        .panel-header {
            padding: 6px 10px;
            background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            cursor: grab;
            position: relative;
            z-index: 1000;
        }

        .panel-header:active {
            cursor: grabbing;
        }

        .panel-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
        }

        .panel-timestamp {
            font-size: 9px;
            color: var(--text-muted);
            margin-left: 8px;
            margin-right: auto;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-variant-numeric: tabular-nums;
        }

        .panel-location {
            font-size: 9px;
            color: var(--text-muted);
            margin-left: 8px;
            margin-right: auto;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .panel-badge {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border-radius: 2px;
            background: rgba(68, 255, 136, 0.1);
            color: var(--status-live);
            border: 1px solid rgba(68, 255, 136, 0.2);
        }

        .panel-header-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .panel-btn {
            font-family: var(--font-body);
            font-size: 12px;
            background: transparent;
            color: var(--text-muted);
            border: none;
            cursor: pointer;
            padding: 0 2px;
            line-height: 1;
            transition: color 0.15s;
        }

        .panel-btn:hover {
            color: var(--text);
        }


        /* Share button tooltip */
        .share-btn {
            font-family: var(--font-body);
            font-size: 12px;
            background: transparent;
            color: var(--text-muted);
            border: none;
            cursor: pointer;
            padding: 2px 4px;
            line-height: 1;
            transition: color 0.15s;
            position: relative;
        }

        .share-btn:hover { color: var(--text); }

        .share-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 14px;
            font-size: 11px;
            font-family: var(--font-body);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .share-toast.show {
            opacity: 1;
        }

        .panel-badge.warning {
            background: rgba(255, 170, 0, 0.1);
            color: var(--status-warning);
            border-color: rgba(255, 170, 0, 0.2);
        }

        .panel-badge.error {
            background: rgba(255, 68, 68, 0.1);
            color: var(--status-error);
            border-color: rgba(255, 68, 68, 0.2);
        }

        .panel-content {
            padding: 8px;
            flex: 1;
            overflow: auto;
        }

        /* === Map Containers === */
        .map-container {
            height: 100%;
            min-height: 200px;
            width: 100%;
        }

        .map-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 200px;
            color: var(--text-muted);
            font-size: 11px;
        }

        .map-data-error {
            font-family: var(--font-body);
            font-size: 10px;
            background: rgba(20, 20, 20, 0.85);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border);
            color: var(--status-warning);
            pointer-events: none;
            white-space: nowrap;
        }

        .chart-unavailable {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--status-warning);
            font-size: 11px;
            letter-spacing: 0.5px;
        }

        /* === Leaflet Legend === */
        .legend {
            font-family: var(--font-body);
            font-size: 10px;
            background: rgba(20, 20, 20, 0.92);
            padding: 6px 8px;
            border: 1px solid var(--border);
            line-height: 1.5;
            color: var(--text-dim);
        }

        .legend strong {
            color: var(--text);
            font-size: 10px;
        }

        .legend-color {
            display: inline-block;
            width: 16px;
            height: 10px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .wind-arrow {
            font-size: 14px;
            font-weight: bold;
        }

        /* === Basin Layer Dropdown === */
        .basin-layer-menu {
            position: relative;
            display: inline-block;
        }

        .basin-layer-btn {
            font-family: var(--font-body);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 8px;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .basin-layer-btn:hover {
            color: var(--text);
            border-color: var(--text-muted);
            background: rgba(255,255,255,0.03);
        }

        .basin-layer-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 4px);
            right: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 4px 0;
            z-index: 1100;
            min-width: 160px;
        }

        .basin-layer-dropdown.open {
            display: block;
        }

        .basin-layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            color: var(--text-dim);
            transition: background 0.1s;
            white-space: nowrap;
            user-select: none;
        }

        .basin-layer-item:hover {
            background: rgba(255,255,255,0.05);
            color: var(--text);
        }

        .basin-layer-item input[type="checkbox"] {
            accent-color: var(--status-live);
            cursor: pointer;
        }

        /* === Panel Toggle Dropdown === */
        .panel-toggle-menu {
            position: relative;
            display: inline-block;
        }

        .panel-toggle-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 4px);
            right: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 4px 0;
            z-index: 1100;
            min-width: 200px;
        }

        .panel-toggle-dropdown.open {
            display: block;
        }

        .panel-toggle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            color: var(--text-dim);
            transition: background 0.1s;
            white-space: nowrap;
            user-select: none;
        }

        .panel-toggle-item:hover {
            background: rgba(255,255,255,0.05);
            color: var(--text);
        }

        .panel-toggle-item input[type="checkbox"] {
            accent-color: var(--status-live);
            cursor: pointer;
        }

        /* === Map Home Button === */
        .map-home-btn {
            width: 26px;
            height: 26px;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 14px;
            line-height: 26px;
            text-align: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .map-home-btn:hover {
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }

        .chart-home-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 10px;
            padding: 2px 8px;
            cursor: pointer;
            border-radius: 3px;
            display: none;
        }

        .chart-home-btn:hover {
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }

        /* === Time Slider === */
        .slider-row {
            padding: 6px 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-label {
            font-size: 10px;
            color: var(--text-muted);
            white-space: nowrap;
            min-width: 0;
            flex-shrink: 0;
        }

        .slider-input {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 3px;
            background: var(--border);
            outline: none;
            border-radius: 2px;
        }

        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--text-dim);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-input::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--text-dim);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-play-btn, .slider-speed-btn {
            font-family: var(--font-body);
            font-size: 12px;
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            padding: 2px 6px;
            line-height: 1;
            transition: all 0.15s;
            flex-shrink: 0;
        }

        .slider-play-btn:hover, .slider-speed-btn:hover {
            color: var(--text);
            border-color: var(--text-muted);
            background: rgba(255,255,255,0.03);
        }

        .slider-play-btn.playing {
            color: var(--status-live);
            border-color: rgba(68, 255, 136, 0.4);
        }

        /* === Current Conditions (stat list) === */
        .stat-list {
            list-style: none;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            border-bottom: 1px solid var(--border);
        }

        .stat-item:last-child { border-bottom: none; }

        .stat-label {
            font-size: 11px;
            color: var(--text-dim);
        }

        .stat-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent);
            font-variant-numeric: tabular-nums;
        }

        /* === Buoy Panel === */
        .buoy-panel-layout {
            display: flex;
            gap: 12px;
            height: 100%;
            min-height: 0;
        }

        .buoy-stats {
            flex: 0 0 26%;
            min-width: 130px;
            overflow-y: auto;
        }

        .buoy-spectrum {
            flex: 1;
            display: flex;
            gap: 8px;
            min-width: 0;
        }

        .buoy-map-wrap {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
        }

        .buoy-map {
            flex: 1;
            min-height: 100px !important;
            border-radius: 3px;
            border: 1px solid var(--border);
        }

        .buoy-loading-overlay {
            position: absolute;
            inset: 0;
            background: var(--surface);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 11px;
            z-index: 10;
        }

        .buoy-selector {
            font-family: var(--font-body);
            font-size: 10px;
            background: var(--surface);
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .buoy-selector:hover {
            color: var(--text);
            border-color: var(--text-muted);
        }

        .spectrum-chart-wrap {
            flex: 1;
            position: relative;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .spectrum-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding-bottom: 2px;
            flex-shrink: 0;
        }

        .spectrum-chart-wrap canvas {
            flex: 1;
            min-height: 0;
        }

        #spectrum-2d-wrap .chart-unavailable {
            position: absolute;
            inset: 0;
            top: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 700px) {
            .buoy-panel-layout {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr;
                gap: 6px;
                height: 100%;
            }
            /* Top-left: compact stats */
            .buoy-stats {
                grid-row: 1;
                grid-column: 1;
                flex: none;
                min-width: 0;
                overflow-y: auto;
            }
            .buoy-stats .stat-list {
                display: flex;
                flex-direction: column;
            }
            .buoy-stats .stat-item {
                padding: 3px 2px;
            }
            .buoy-stats .stat-label {
                font-size: 10px;
            }
            .buoy-stats .stat-value {
                font-size: 10px;
            }
            /* Top-right: map (placed explicitly since DOM order differs) */
            .buoy-map-wrap {
                grid-row: 1;
                grid-column: 2;
                flex: none;
                height: auto;
                min-height: 80px;
            }
            .buoy-map {
                min-height: 0 !important;
                height: 100%;
            }
            /* Bottom: spectrum plots side by side, spanning full width */
            .buoy-spectrum {
                grid-row: 2;
                grid-column: 1 / -1;
                gap: 6px;
                min-height: 0;
                overflow: hidden;
            }
            .spectrum-chart-wrap {
                min-height: 0;
                overflow: hidden;
            }
            .spectrum-chart-wrap canvas {
                min-height: 0;
            }
        }

        /* === Offshore indicator === */
        .conditions-hint {
            font-size: 10px;
            color: var(--text-muted);
            padding: 4px 4px 0;
        }

        .conditions-hint .good { color: var(--status-live); }

        /* === Data Table === */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .data-table thead {
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .data-table th {
            padding: 6px 6px;
            text-align: left;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .data-table td {
            padding: 5px 6px;
            color: var(--text-dim);
            border-bottom: 1px solid rgba(42, 42, 42, 0.5);
            font-variant-numeric: tabular-nums;
        }

        .data-table tr.row-good td {
            color: var(--status-live);
        }

        /* === Charts === */
        .chart-wrap {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* === Modal (custom, no Bootstrap) === */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal-card {
            background: var(--surface);
            border: 1px solid var(--border);
            width: 100%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .modal-top {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text);
        }

        .modal-close {
            font-family: var(--font-body);
            font-size: 16px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text); }

        .modal-body {
            padding: 12px 14px;
            flex: 1;
            overflow: auto;
        }

        .modal-body p {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .modal-selected {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 10px;
        }

        .modal-selected strong {
            color: var(--text);
        }

        .location-search {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .location-search input {
            flex: 1;
            font-family: var(--font-body);
            font-size: 11px;
            padding: 6px 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            outline: none;
        }

        .location-search input::placeholder {
            color: var(--text-dim);
        }

        .location-search button {
            font-family: var(--font-body);
            font-size: 11px;
            padding: 6px 12px;
            background: var(--accent);
            border: 1px solid var(--accent);
            color: var(--bg);
            cursor: pointer;
            white-space: nowrap;
        }

        .location-search button:hover {
            opacity: 0.85;
        }

        /* === Favorites === */
        .favorites-section {
            margin-bottom: 10px;
        }

        .favorites-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .favorites-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .favorite-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 11px;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.15s;
            max-width: 200px;
        }

        .favorite-item:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text);
            border-color: var(--text-muted);
        }

        .favorite-item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .favorite-item-remove {
            font-size: 13px;
            color: var(--text-muted);
            cursor: pointer;
            line-height: 1;
            padding: 0 2px;
            flex-shrink: 0;
        }

        .favorite-item-remove:hover {
            color: var(--status-error);
        }

        .btn-save-favorite {
            font-family: var(--font-body);
            font-size: 11px;
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            margin-right: auto;
            transition: all 0.15s;
        }

        .btn-save-favorite:hover {
            color: var(--text);
            border-color: var(--text-muted);
        }

        .btn-save-favorite:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-save-favorite.saved {
            color: var(--status-live);
            border-color: rgba(68, 255, 136, 0.3);
        }

        .modal-footer {
            padding: 10px 14px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .btn-modal {
            font-family: var(--font-body);
            font-size: 11px;
            padding: 6px 14px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-modal:hover {
            color: var(--text);
            border-color: var(--text-muted);
        }

        .btn-modal.primary {
            background: rgba(255,255,255,0.05);
            color: var(--text);
            border-color: var(--text-muted);
        }

        .btn-modal.primary:hover {
            background: rgba(255,255,255,0.1);
        }

        .btn-modal:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* === Responsive === */
        @media (min-width: 701px) {
            .btn-icon-only { display: none; }
        }

        @media (max-width: 700px) {
            .header-center { display: none; }
            .header-left .share-btn,
            .header-left .header-version { display: none; }
            .header-clock { display: none; }
            .header-title { font-size: 11px; letter-spacing: 1px; }
            .header { gap: 8px; padding: 0 8px; }
            .header-left { gap: 8px; }
            .header-right { gap: 6px; }
            .btn-text { display: none; }
            .btn-icon-only { display: inline-flex; align-items: center; justify-content: center; }
            .header-btn { min-height: 36px; min-width: 36px; display: inline-flex; align-items: center; justify-content: center; }
            .modal-overlay { padding: 10px; }
            .modal-card { max-height: 95vh; }
            #location-map { height: 300px !important; }
            .location-search input { font-size: 16px; padding: 10px; }
            .location-search button { font-size: 14px; padding: 10px 14px; }
            .favorite-item { padding: 6px 10px; font-size: 13px; }
            .btn-save-favorite { font-size: 13px; padding: 8px 14px; }
        }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <a href="https://freesurfforecast.com/" class="header-title" style="text-decoration:none;color:inherit;">Free Surf Forecast</a>
            <button class="share-btn" onclick="copyShareLink()" title="Copy link">&#x1F517;</button>
            <a href="https://www.instagram.com/freesurfforecast/" target="_blank" rel="noopener" class="share-btn" title="Instagram" style="text-decoration:none;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><circle cx="12" cy="12" r="5"/><circle cx="17.5" cy="6.5" r="1.5"/></svg></a>
            <a href="https://github.com/ajkammerer93/surf_dash" target="_blank" rel="noopener" class="share-btn" title="GitHub" style="text-decoration:none;"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg></a>
            <span class="header-version">{{ version }}</span>
        </div>
        <div class="header-center" onclick="openModal()">
            <span class="header-location" id="location-name">Surf City, North Carolina</span>
            <span class="header-coords">
                <span id="display-lat">34.43</span>, <span id="display-lon">-77.54</span>
            </span>
        </div>
        <div class="header-right">
            <span class="header-clock" id="header-clock"></span>
            <div class="panel-toggle-menu">
                <button class="header-btn" id="panels-toggle-btn">
                    <span class="btn-text">Panels &#9662;</span>
                    <span class="btn-icon-only" title="Panels">&#9776;</span>
                </button>
                <div class="panel-toggle-dropdown" id="panel-toggle-dropdown"></div>
            </div>
            <button class="header-btn" onclick="openModal()">
                <span class="btn-text">Change Location</span>
                <span class="btn-icon-only" title="Change Location">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/>
                        <circle cx="12" cy="9" r="2.5"/>
                    </svg>
                </span>
            </button>
            <button class="header-btn" id="page-fullscreen-btn" onclick="togglePageFullscreen()" title="Fullscreen">&#x26F6;</button>
        </div>
    </div>

    <div class="share-toast" id="share-toast">Link copied to clipboard</div>

    <!-- Location Modal -->
    <div class="modal-overlay" id="locationModal">
        <div class="modal-card">
            <div class="modal-top">
                <span class="modal-title">Select Location</span>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="favorites-section" id="favorites-section" style="display:none;">
                    <div class="favorites-label">Saved Locations</div>
                    <div class="favorites-list" id="favorites-list"></div>
                </div>
                <div class="location-search">
                    <input type="text" id="location-search-input" placeholder="Search for a location (e.g. Santa Monica, Pipeline Hawaii)">
                    <button id="location-search-btn">Search</button>
                </div>
                <p>Or click anywhere on the map to select a location.</p>
                <div id="location-map" style="height: 420px;"></div>
                <div class="modal-selected">
                    <strong>Selected:</strong> <span id="selected-location-text">None</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-save-favorite" id="save-favorite-btn" disabled>&#9734; Save</button>
                <button class="btn-modal" onclick="closeModal()">Cancel</button>
                <button class="btn-modal primary" id="confirm-location-btn" disabled>Load Forecast</button>
            </div>
        </div>
    </div>

    <!-- Dashboard Grid -->
    <div class="grid-stack" id="dashboard-grid">

        <!-- Current Conditions -->
        <div class="grid-stack-item" data-panel-id="conditions" gs-x="0" gs-y="0" gs-w="4" gs-h="4">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Current Conditions</span>
                        <span class="panel-location"></span>
                        <span class="panel-badge">Live</span>
                    </div>
                    <div class="panel-content" id="current-conditions-content">
                        <ul class="stat-list" id="current-conditions-stats">
                            <li class="stat-item">
                                <span class="stat-label">Wave Height</span>
                                <span class="stat-value" id="current_wave_height">- ft</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Wave Period</span>
                                <span class="stat-value" id="current_wave_period">- s</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Wave Direction</span>
                                <span class="stat-value" id="current_wave_direction">- &deg;</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Wind Speed</span>
                                <span class="stat-value" id="current_wind_speed">-</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Wind Direction</span>
                                <span class="stat-value" id="current_wind_direction">-</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Air Temp</span>
                                <span class="stat-value" id="current_air_temp">-</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Water Temp</span>
                                <span class="stat-value" id="current_water_temp">-</span>
                            </li>
                        </ul>
                        <div class="chart-unavailable" id="current-conditions-error" style="display:none">Conditions data unavailable</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Surf Cam 1 -->
        <div class="grid-stack-item" data-panel-id="cam-1" gs-x="4" gs-y="0" gs-w="4" gs-h="4">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title" id="cam-1-title">Live Cam</span>
                        <span class="panel-badge" id="cam-1-badge">Loading</span>
                    </div>
                    <div class="panel-content" id="cam-1-content" style="padding: 0;">
                        <div style="padding: 16px; color: var(--text-muted); font-size: 11px;">Finding nearest camera...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Surf Cam 2 -->
        <div class="grid-stack-item" data-panel-id="cam-2" gs-x="8" gs-y="0" gs-w="4" gs-h="4">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title" id="cam-2-title">Live Cam</span>
                        <span class="panel-badge" id="cam-2-badge">Loading</span>
                    </div>
                    <div class="panel-content" id="cam-2-content" style="padding: 0;">
                        <div style="padding: 16px; color: var(--text-muted); font-size: 11px;">Finding nearest camera...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Ocean Basin -->
        <div class="grid-stack-item" data-panel-id="ocean-basin" gs-x="0" gs-y="4" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Ocean Basin</span>
                        <span class="panel-timestamp" id="ts-ocean-basin"></span>
                        <div class="panel-header-actions">
                            <div class="basin-layer-menu">
                                <button class="basin-layer-btn" onclick="toggleBasinLayerMenu(event)">Layers &#9662;</button>
                                <div class="basin-layer-dropdown" id="basin-layer-dropdown">
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-height" checked onchange="onBasinLayerToggle('height')">
                                        Wave Height
                                    </label>
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-period" onchange="onBasinLayerToggle('period')">
                                        Wave Period
                                    </label>
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-direction" onchange="onBasinLayerToggle('direction')">
                                        Wave Direction
                                    </label>
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-wind" checked onchange="onBasinLayerToggle('wind')">
                                        Wind Animation
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="panel-content">
                        <div id="map-basin" class="map-container">
                            <div class="map-loading">Loading ocean data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Local Wave Height -->
        <div class="grid-stack-item" data-panel-id="local-wave-height" gs-x="0" gs-y="9" gs-w="4" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Local Wave Height (ft)</span>
                        <span class="panel-timestamp" id="ts-local-wave-height"></span>
                    </div>
                    <div class="panel-content">
                        <div id="map-wave-height" class="map-container">
                            <div class="map-loading">Loading map data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Local Wind Speed -->
        <div class="grid-stack-item" data-panel-id="local-wind" gs-x="4" gs-y="9" gs-w="4" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Local Wind Speed &amp; Direction</span>
                        <span class="panel-timestamp" id="ts-local-wind"></span>
                    </div>
                    <div class="panel-content">
                        <div id="map-wind" class="map-container">
                            <div class="map-loading">Loading map data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Local Wave Period -->
        <div class="grid-stack-item" data-panel-id="local-wave-period" gs-x="8" gs-y="9" gs-w="4" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Local Wave Period (s)</span>
                        <span class="panel-timestamp" id="ts-local-wave-period"></span>
                    </div>
                    <div class="panel-content">
                        <div id="map-wave-period" class="map-container">
                            <div class="map-loading">Loading map data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Unified Map Time Slider -->
        <div class="grid-stack-item" data-panel-id="map-time" gs-x="0" gs-y="14" gs-w="12" gs-h="1" gs-no-resize="true">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Map Time</span>
                        <span class="panel-badge" id="map-time-badge">Loading</span>
                    </div>
                    <div class="panel-content" style="padding: 0;">
                        <div class="slider-row">
                            <span class="slider-label" id="time-label">Time:</span>
                            <button class="slider-play-btn" id="slider-play-btn" title="Play">&#9654;</button>
                            <input type="range" class="slider-input" id="time-slider" min="0" max="0" step="1">
                            <button class="slider-speed-btn" id="slider-speed-btn" title="Playback speed">1x</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Buoy Observations -->
        <div class="grid-stack-item" data-panel-id="buoys" gs-x="0" gs-y="15" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Buoy Observations</span>
                        <select class="buoy-selector" id="buoy-selector" title="Select buoy"></select>
                        <span class="panel-timestamp" id="buoy-timestamp"></span>
                        <div class="panel-header-actions">
                            <span class="panel-badge" id="buoy-badge">Live</span>
                        </div>
                    </div>
                    <div class="panel-content" id="buoy-panel-content">
                        <div class="buoy-panel-layout">
                            <div class="buoy-stats">
                                <ul class="stat-list" id="buoy-stats-list">
                                    <li class="stat-item"><span class="stat-label">Wave Height</span><span class="stat-value" id="buoy_wave_height">-</span></li>
                                    <li class="stat-item"><span class="stat-label">Period</span><span class="stat-value" id="buoy_wave_period">-</span></li>
                                    <li class="stat-item"><span class="stat-label">Direction</span><span class="stat-value" id="buoy_wave_dir">-</span></li>
                                    <li class="stat-item"><span class="stat-label">Wind</span><span class="stat-value" id="buoy_wind">-</span></li>
                                    <li class="stat-item"><span class="stat-label">Water Temp</span><span class="stat-value" id="buoy_water_temp">-</span></li>
                                    <li class="stat-item"><span class="stat-label">Air Temp</span><span class="stat-value" id="buoy_air_temp">-</span></li>
                                    <li class="stat-item"><span class="stat-label">Pressure</span><span class="stat-value" id="buoy_pressure">-</span></li>
                                </ul>
                            </div>
                            <div class="buoy-spectrum">
                                <div class="spectrum-chart-wrap" id="spectrum-1d-wrap">
                                    <div class="spectrum-label">Energy Spectrum</div>
                                    <canvas id="spectrumChart"></canvas>
                                </div>
                                <div class="spectrum-chart-wrap" id="spectrum-2d-wrap">
                                    <div class="spectrum-label">Directional</div>
                                    <canvas id="polarCanvas"></canvas>
                                    <div class="chart-unavailable" id="directional-unavailable" style="display:none">No directional data</div>
                                </div>
                            </div>
                            <div class="buoy-map-wrap">
                                <div id="buoy-map" class="buoy-map map-container"></div>
                            </div>
                        </div>
                        <div class="chart-unavailable" id="buoy-error" style="display:none">No buoys found nearby</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wave & Wind Chart -->
        <div class="grid-stack-item" data-panel-id="wave-wind-chart" gs-x="0" gs-y="20" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Wave &amp; Wind Forecast</span>
                        <span class="panel-location"></span>
                        <button class="chart-home-btn" id="wave-chart-reset" onclick="resetWaveChart()">Reset Zoom</button>
                    </div>
                    <div class="panel-content">
                        <div class="chart-wrap">
                            <canvas id="waveChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tidal Predictions -->
        <div class="grid-stack-item" data-panel-id="tides" gs-x="0" gs-y="25" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Tidal Predictions</span>
                        <button class="chart-home-btn" id="tide-chart-reset" onclick="resetTideChart()">Reset Zoom</button>
                        <span class="panel-badge" id="tide-station-info">Loading station</span>
                    </div>
                    <div class="panel-content">
                        <div class="chart-wrap">
                            <canvas id="tideChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Daylight Forecast -->
        <div class="grid-stack-item" data-panel-id="daylight" gs-x="0" gs-y="30" gs-w="12" gs-h="6">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Daylight Forecast</span>
                        <span class="panel-location"></span>
                    </div>
                    <div class="panel-content">
                        <p class="conditions-hint">
                            <span class="good">&#10003;</span> = Offshore/calm wind (NW &plusmn;45&deg; or &lt;3 mph) &mdash; good conditions
                        </p>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Waves (ft)</th>
                                    <th>Period (s)</th>
                                    <th>Wind (mph)</th>
                                    <th>Wind Dir</th>
                                </tr>
                            </thead>
                            <tbody id="forecast-table"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- JS Libraries (no Bootstrap JS) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-velocity@2.1.4/dist/leaflet-velocity.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <!-- GridStack JS -->
    <script src="https://cdn.jsdelivr.net/npm/gridstack@10/dist/gridstack-all.js"></script>

    <script>
        // === Share Link ===
        function copyShareLink() {
            const url = new URL('https://freesurfforecast.com');
            if (currentLocation) {
                url.searchParams.set('lat', currentLocation.lat.toFixed(4));
                url.searchParams.set('lon', currentLocation.lon.toFixed(4));
                if (currentLocation.name) url.searchParams.set('name', currentLocation.name);
            }
            navigator.clipboard.writeText(url.toString()).then(function() {
                const toast = document.getElementById('share-toast');
                toast.classList.add('show');
                setTimeout(function() { toast.classList.remove('show'); }, 2000);
            });
        }

        // === GridStack Init ===
        let dashboardGrid = null;

        document.addEventListener('DOMContentLoaded', function() {
            // Restore saved layout if available
            const savedLayout = localStorage.getItem('dashboard-layout');

            var isMobile = window.innerWidth <= 700;

            dashboardGrid = GridStack.init({
                cellHeight: 70,
                margin: 2,
                column: 12,
                float: false,
                handle: '.panel-header',
                oneColumnSize: 700,
                acceptWidgets: false,
                disableDrag: isMobile,
                disableResize: isMobile
            }, '#dashboard-grid');

            if (savedLayout) {
                try {
                    const items = JSON.parse(savedLayout);
                    dashboardGrid.load(items, false);
                } catch (e) {
                    console.warn('Failed to restore layout:', e);
                }
            }

            // Save layout on change
            dashboardGrid.on('change', function(event, items) {
                saveLayout();
                invalidateAllMapsAndCharts();
            });

            // Invalidate maps/charts after resize
            dashboardGrid.on('resizestop', function(event, el) {
                setTimeout(function() {
                    el.querySelectorAll('.map-container').forEach(function(container) {
                        const mapInstance = getMapById(container.id);
                        if (mapInstance) mapInstance.invalidateSize();
                    });
                    el.querySelectorAll('canvas').forEach(function(canvas) {
                        const chart = Chart.getChart(canvas);
                        if (chart) chart.resize();
                    });
                }, 100);
            });

            // Toggle drag/resize on window resize (e.g. phone rotation)
            window.addEventListener('resize', function() {
                var mobile = window.innerWidth <= 700;
                dashboardGrid.enableMove(!mobile);
                dashboardGrid.enableResize(!mobile);
            });
        });

        function saveLayout() {
            if (!dashboardGrid) return;
            const items = dashboardGrid.save(false);
            localStorage.setItem('dashboard-layout', JSON.stringify(items));
        }

        function invalidateAllMapsAndCharts() {
            setTimeout(function() {
                document.querySelectorAll('.map-container').forEach(function(container) {
                    const mapInstance = getMapById(container.id);
                    if (mapInstance) mapInstance.invalidateSize();
                });
                document.querySelectorAll('.chart-wrap canvas').forEach(function(canvas) {
                    const chart = Chart.getChart(canvas);
                    if (chart) chart.resize();
                });
            }, 100);
        }

        // === Panel Visibility Toggle ===
        const PANEL_NAMES = {
            'conditions': 'Current Conditions',
            'cam-1': 'Live Cam 1',
            'cam-2': 'Live Cam 2',
            'ocean-basin': 'Ocean Basin',
            'local-wave-height': 'Local Wave Height',
            'local-wind': 'Local Wind Speed & Direction',
            'local-wave-period': 'Local Wave Period',
            'map-time': 'Map Time',
            'buoys': 'Buoy Observations',
            'wave-wind-chart': 'Wave & Wind Forecast',
            'tides': 'Tidal Predictions',
            'daylight': 'Daylight Forecast'
        };

        function getHiddenPanels() {
            try {
                return JSON.parse(localStorage.getItem('hidden-panels')) || [];
            } catch (e) {
                return [];
            }
        }

        function saveHiddenPanels(hidden) {
            localStorage.setItem('hidden-panels', JSON.stringify(hidden));
        }

        function togglePanel(panelId, visible) {
            const el = document.querySelector(`.grid-stack-item[data-panel-id="${panelId}"]`);
            if (!el || !dashboardGrid) return;

            const hidden = getHiddenPanels();
            if (visible) {
                const idx = hidden.indexOf(panelId);
                if (idx !== -1) hidden.splice(idx, 1);
            } else {
                if (!hidden.includes(panelId)) hidden.push(panelId);
            }
            saveHiddenPanels(hidden);

            if (visible) {
                // Re-add widget to grid so it flows back into position
                el.style.display = '';
                dashboardGrid.addWidget(el);
                dashboardGrid.compact();
                setTimeout(function() {
                    el.querySelectorAll('.map-container').forEach(function(container) {
                        const mapInstance = getMapById(container.id);
                        if (mapInstance) mapInstance.invalidateSize();
                    });
                    el.querySelectorAll('canvas').forEach(function(canvas) {
                        const chart = Chart.getChart(canvas);
                        if (chart) chart.resize();
                    });
                }, 100);
            } else {
                // Remove widget from grid engine (keeps DOM node) so others collapse up
                dashboardGrid.removeWidget(el, false);
                el.style.display = 'none';
            }
        }

        function applyHiddenPanels() {
            const hidden = getHiddenPanels();
            hidden.forEach(function(panelId) {
                const el = document.querySelector(`.grid-stack-item[data-panel-id="${panelId}"]`);
                if (el && dashboardGrid) {
                    dashboardGrid.removeWidget(el, false);
                    el.style.display = 'none';
                }
            });
        }

        function buildPanelToggleDropdown() {
            const dropdown = document.getElementById('panel-toggle-dropdown');
            const hidden = getHiddenPanels();
            dropdown.innerHTML = '';
            Object.keys(PANEL_NAMES).forEach(function(panelId) {
                const label = document.createElement('label');
                label.className = 'panel-toggle-item';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = !hidden.includes(panelId);
                cb.addEventListener('change', function() {
                    togglePanel(panelId, cb.checked);
                });
                label.appendChild(cb);
                label.appendChild(document.createTextNode(PANEL_NAMES[panelId]));
                dropdown.appendChild(label);
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Migrate old cam panel IDs
            var hidden = getHiddenPanels();
            var migrated = false;
            ['cam-surfcity', 'cam-topsail'].forEach(function(oldId, i) {
                var idx = hidden.indexOf(oldId);
                if (idx !== -1) { hidden[idx] = 'cam-' + (i + 1); migrated = true; }
            });
            if (migrated) saveHiddenPanels(hidden);

            // Apply saved hidden panels after GridStack init
            setTimeout(applyHiddenPanels, 0);

            // Panels toggle button
            document.getElementById('panels-toggle-btn').addEventListener('click', function(e) {
                e.stopPropagation();
                const dropdown = document.getElementById('panel-toggle-dropdown');
                const isOpen = dropdown.classList.contains('open');
                if (!isOpen) buildPanelToggleDropdown();
                dropdown.classList.toggle('open');
            });

            // Close panel toggle dropdown on outside click
            document.addEventListener('click', function(e) {
                const dropdown = document.getElementById('panel-toggle-dropdown');
                if (dropdown && !e.target.closest('.panel-toggle-menu')) {
                    dropdown.classList.remove('open');
                }
            });
        });

        // === Panel Fullscreen ===
        function toggleFullscreen(btn) {
            const gsItem = btn.closest('.grid-stack-item');
            const isFullscreen = gsItem.classList.toggle('panel-fullscreen-wrapper');
            btn.textContent = isFullscreen ? '\u2716' : '\u26F6';
            btn.title = isFullscreen ? 'Exit fullscreen' : 'Fullscreen';

            // Disable/enable GridStack drag+resize while fullscreen
            if (dashboardGrid) {
                if (isFullscreen) {
                    dashboardGrid.movable(gsItem, false);
                    dashboardGrid.resizable(gsItem, false);
                } else {
                    dashboardGrid.movable(gsItem, true);
                    dashboardGrid.resizable(gsItem, true);
                }
            }

            // Invalidate Leaflet maps inside this widget
            setTimeout(function() {
                gsItem.querySelectorAll('.map-container').forEach(function(container) {
                    const mapId = container.id;
                    const mapInstance = getMapById(mapId);
                    if (mapInstance) mapInstance.invalidateSize();
                });
                // Resize Chart.js canvases
                gsItem.querySelectorAll('canvas').forEach(function(canvas) {
                    const chart = Chart.getChart(canvas);
                    if (chart) chart.resize();
                });
            }, 100);
        }

        function getMapById(id) {
            const mapLookup = {
                'map-basin': () => mapBasin,
                'map-wave-period': () => map1,
                'map-wave-height': () => map2,
                'map-wind': () => map3,
                'buoy-map': () => typeof buoyMap !== 'undefined' ? buoyMap : null,
            };
            return mapLookup[id] ? mapLookup[id]() : null;
        }

        // Inject fullscreen buttons into all panel headers
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.grid-stack-item-content .panel > .panel-header').forEach(function(header) {
                // Wrap existing badge(s) and add fullscreen button
                const actions = document.createElement('div');
                actions.className = 'panel-header-actions';

                // Move existing badges into actions container
                header.querySelectorAll('.panel-badge').forEach(function(badge) {
                    actions.appendChild(badge);
                });

                const btn = document.createElement('button');
                btn.className = 'panel-btn';
                btn.textContent = '\u26F6';
                btn.title = 'Fullscreen';
                btn.onclick = function() { toggleFullscreen(this); };
                actions.appendChild(btn);

                header.appendChild(actions);
            });
        });

        // ESC to exit fullscreen
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const fs = document.querySelector('.panel-fullscreen-wrapper');
                if (fs) {
                    const btn = fs.querySelector('.panel-btn');
                    if (btn) toggleFullscreen(btn);
                }
            }
        });

        // === Page Fullscreen ===
        function togglePageFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        document.addEventListener('fullscreenchange', function() {
            const btn = document.getElementById('page-fullscreen-btn');
            btn.textContent = document.fullscreenElement ? '\u2716' : '\u26F6';
            btn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Fullscreen';
        });

        // === Unit Conversions ===
        const M_TO_FT = 3.28084;
        const KMH_TO_MPH = 0.621371;
        const KM_TO_MI = 0.621371;

        // === Unified Map Data Globals ===
        let basinGridData = null;
        let localGridData = null;

        // === Persistent rectangle/marker caches for slider reuse ===
        let basinRectangles = [];       // [{rect, i, j}]
        let localPeriodRects = [];      // [{rect, i, j}]
        let localHeightRects = [];      // [{rect, i, j}]
        let localWindMarkers = [];      // [{marker, i, j, arrowDiv}]
        let basinRectsBuilt = false;    // true after first full build
        let localRectsBuilt = false;    // true after first full build

        // === Batch rendering state ===
        let batchGeneration = 0;        // incremented on each new batch to cancel stale ones
        let sliderRafId = null;         // for slider debounce

        // === Slider Animation State ===
        let sliderAnimationId = null;
        let sliderAnimationSpeed = 3000;
        const SLIDER_SPEEDS = [6000, 3000, 1500];
        const SLIDER_SPEED_LABELS = ['0.5x', '1x', '2x'];
        let sliderSpeedIndex = 1;
        const SLIDER_ANIMATION_STEP = 3;  // advance 3 hours per tick (Windy-style)

        // === Lazy render state ===
        let basinDataReady = false;     // data fetched, waiting for visibility
        let localDataReady = false;
        let basinRendered = false;      // map initialized and first render done
        let localRendered = false;

        // === Ocean Canvas Clipping ===
        // Clip grid data to ocean using the coastline GeoJSON as a canvas clip path.
        // Grid cells are drawn on a canvas, clipped to the ocean shape  no mask layer needed,
        // no alignment issues, Windy-style sharp coastline boundary.
        let landPolygons = [];

        fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-10m.json')
            .then(r => r.json())
            .then(topo => {
                const geojson = topojson.feature(topo, topo.objects.land);
                geojson.features.forEach(feature => {
                    const coords = feature.geometry.coordinates;
                    if (feature.geometry.type === 'Polygon') {
                        landPolygons.push(coords[0]);
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        coords.forEach(poly => landPolygons.push(poly[0]));
                    }
                });
                landPolygons = landPolygons.map(ring => {
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    ring.forEach(([x, y]) => {
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                    });
                    return { ring, bbox: [minX, minY, maxX, maxY] };
                });
                console.log(`Loaded ${landPolygons.length} land polygons for ocean clipping`);
            })
            .catch(err => console.warn('Land TopoJSON fetch failed:', err));

        // Patch L.Canvas renderer to clip drawing to ocean when oceanClip option is set
        const _origCanvasDraw = L.Canvas.prototype._draw;
        L.Canvas.prototype._draw = function() {
            if (this.options.oceanClip && landPolygons.length && this._map) {
                const ctx = this._ctx;
                const map = this._map;
                const mapBounds = map.getBounds();

                ctx.save();
                ctx.beginPath();
                ctx.rect(-1e7, -1e7, 2e7, 2e7);

                for (const { ring, bbox } of landPolygons) {
                    if (bbox[2] < mapBounds.getWest() || bbox[0] > mapBounds.getEast() ||
                        bbox[3] < mapBounds.getSouth() || bbox[1] > mapBounds.getNorth()) continue;
                    let first = true;
                    for (const [lon, lat] of ring) {
                        const p = map.latLngToLayerPoint([lat, lon]);
                        if (first) { ctx.moveTo(p.x, p.y); first = false; }
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.closePath();
                }
                ctx.clip('evenodd');
            }
            _origCanvasDraw.call(this);
            if (this.options.oceanClip && landPolygons.length && this._map) {
                this._ctx.restore();
            }
        };

        function addMapDataError(map, message) {
            const ctrl = L.control({ position: 'topright' });
            ctrl.onAdd = function() {
                const div = L.DomUtil.create('div', 'map-data-error');
                div.textContent = message;
                return div;
            };
            ctrl.addTo(map);
        }

        function showChartUnavailable(canvasId, message) {
            const canvas = document.getElementById(canvasId);
            const wrap = canvas.parentElement;
            canvas.style.display = 'none';
            let overlay = wrap.querySelector('.chart-unavailable');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'chart-unavailable';
                wrap.appendChild(overlay);
            }
            overlay.textContent = message;
        }

        function clearChartUnavailable(canvasId) {
            const canvas = document.getElementById(canvasId);
            const wrap = canvas.parentElement;
            canvas.style.display = '';
            const overlay = wrap.querySelector('.chart-unavailable');
            if (overlay) overlay.remove();
        }

        function initEmptyMap(containerId, center, zoom, errorMessage) {
            const el = document.getElementById(containerId);
            el.innerHTML = '';
            const map = L.map(containerId).setView(center, zoom);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                maxZoom: 19
            }).addTo(map);
            addHomeButton(map, center, zoom);
            addMapDataError(map, errorMessage);
            setTimeout(() => map.invalidateSize(), 100);
            return map;
        }

        // === Shared Time Axis ===
        let waveTimeRange = null;   // { min: Date, max: Date }
        let tideTimeRange = null;
        function syncChartTimeAxes() {
            if (!waveTimeRange || !tideTimeRange) return;
            // Use the intersection so both charts cover the same time window
            const sharedMin = new Date(Math.max(waveTimeRange.min, tideTimeRange.min));
            const sharedMax = new Date(Math.min(waveTimeRange.max, tideTimeRange.max));
            if (waveChart && waveChart.canvas) {
                waveChart.options.scales.x.min = sharedMin;
                waveChart.options.scales.x.max = sharedMax;
                waveChart.update('none');
            }
            if (tideChart && tideChart.canvas) {
                tideChart.options.scales.x.min = sharedMin;
                tideChart.options.scales.x.max = sharedMax;
                tideChart.update('none');
            }
        }

        function resetWaveChart() {
            if (waveChart) {
                waveChart.resetZoom();
                syncChartTimeAxes();
            }
            document.getElementById('wave-chart-reset').style.display = 'none';
        }

        function resetTideChart() {
            if (tideChart) {
                tideChart.resetZoom();
                syncChartTimeAxes();
            }
            document.getElementById('tide-chart-reset').style.display = 'none';
        }

        // === Live Clock ===
        function updateClock() {
            const now = new Date();
            const h = String(now.getHours()).padStart(2, '0');
            const m = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('header-clock').textContent = h + ':' + m + ':' + s;
        }
        setInterval(updateClock, 1000);
        updateClock();

        // === Map Home Button Control ===
        function addHomeButton(map, center, zoom) {
            const HomeControl = L.Control.extend({
                options: { position: 'topleft' },
                onAdd: function() {
                    const btn = L.DomUtil.create('div', 'map-home-btn');
                    btn.innerHTML = '&#8962;';
                    btn.title = 'Reset view';
                    L.DomEvent.disableClickPropagation(btn);
                    L.DomEvent.on(btn, 'click', function() {
                        map.setView(center, zoom);
                    });
                    return btn;
                }
            });
            map.addControl(new HomeControl());
        }

        // === Custom Modal ===
        function openModal() {
            const modal = document.getElementById('locationModal');
            modal.classList.add('open');
            renderFavoritesList();
            updateSaveFavoriteButton();
            // Initialize or refresh the Leaflet map
            setTimeout(function() {
                if (!locationMap) {
                    initLocationMap();
                } else {
                    locationMap.invalidateSize();
                }
            }, 100);
        }

        function closeModal() {
            document.getElementById('locationModal').classList.remove('open');
        }

        // Close modal on overlay click (but not on card click)
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('locationModal');
            if (e.target === modal) {
                closeModal();
            }
        });

        // === Global location state ===
        const DEFAULT_LOCATION = {
            lat: 34.42711,
            lon: -77.54608,
            name: 'Surf City, North Carolina'
        };

        function getInitialLocation() {
            // Priority 1: URL params
            const params = new URLSearchParams(window.location.search);
            const urlLat = parseFloat(params.get('lat'));
            const urlLon = parseFloat(params.get('lon'));
            if (!isNaN(urlLat) && !isNaN(urlLon)) {
                return {
                    lat: urlLat,
                    lon: urlLon,
                    name: params.get('name') || `Location (${urlLat.toFixed(2)}, ${urlLon.toFixed(2)})`
                };
            }
            // Priority 2: localStorage last-location
            try {
                const saved = JSON.parse(localStorage.getItem('last-location'));
                if (saved && typeof saved.lat === 'number' && typeof saved.lon === 'number') {
                    return saved;
                }
            } catch (e) {}
            // Priority 3: default
            return { ...DEFAULT_LOCATION };
        }

        let currentLocation = getInitialLocation();
        let selectedLocation = null;
        let locationMap = null;
        let locationMarker = null;

        // === Saved Locations (Favorites) ===
        function getSavedLocations() {
            try {
                return JSON.parse(localStorage.getItem('saved-locations')) || [];
            } catch (e) {
                return [];
            }
        }

        function saveSavedLocations(locations) {
            localStorage.setItem('saved-locations', JSON.stringify(locations));
        }

        function addSavedLocation(loc) {
            const locations = getSavedLocations();
            const roundedLat = parseFloat(loc.lat.toFixed(4));
            const roundedLon = parseFloat(loc.lon.toFixed(4));
            const exists = locations.some(l =>
                parseFloat(l.lat.toFixed(4)) === roundedLat &&
                parseFloat(l.lon.toFixed(4)) === roundedLon
            );
            if (exists) return false;
            if (locations.length >= 10) return null; // at capacity
            locations.push({ lat: loc.lat, lon: loc.lon, name: loc.name });
            saveSavedLocations(locations);
            return true;
        }

        function removeSavedLocation(index) {
            const locations = getSavedLocations();
            if (index >= 0 && index < locations.length) {
                locations.splice(index, 1);
                saveSavedLocations(locations);
            }
        }

        function isLocationSaved(loc) {
            if (!loc) return false;
            const locations = getSavedLocations();
            const roundedLat = parseFloat(loc.lat.toFixed(4));
            const roundedLon = parseFloat(loc.lon.toFixed(4));
            return locations.some(l =>
                parseFloat(l.lat.toFixed(4)) === roundedLat &&
                parseFloat(l.lon.toFixed(4)) === roundedLon
            );
        }

        function renderFavoritesList() {
            const list = document.getElementById('favorites-list');
            const section = document.getElementById('favorites-section');
            const locations = getSavedLocations();
            list.innerHTML = '';
            if (locations.length === 0) {
                section.style.display = 'none';
                return;
            }
            section.style.display = '';
            locations.forEach(function(loc, index) {
                const chip = document.createElement('div');
                chip.className = 'favorite-item';
                chip.title = loc.name + ' (' + loc.lat.toFixed(4) + ', ' + loc.lon.toFixed(4) + ')';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'favorite-item-name';
                nameSpan.textContent = loc.name;
                chip.appendChild(nameSpan);

                const removeBtn = document.createElement('span');
                removeBtn.className = 'favorite-item-remove';
                removeBtn.innerHTML = '&times;';
                removeBtn.title = 'Remove';
                removeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    removeSavedLocation(index);
                    renderFavoritesList();
                    updateSaveFavoriteButton();
                });
                chip.appendChild(removeBtn);

                chip.addEventListener('click', function() {
                    // Select this favorite
                    selectedLocation = { lat: loc.lat, lon: loc.lon, name: loc.name };
                    document.getElementById('selected-location-text').textContent =
                        loc.name + ' (' + loc.lat.toFixed(4) + ', ' + loc.lon.toFixed(4) + ')';
                    document.getElementById('confirm-location-btn').disabled = false;
                    document.getElementById('save-favorite-btn').disabled = false;

                    // Fly map to location and place marker
                    if (locationMap) {
                        locationMap.flyTo([loc.lat, loc.lon], 10);
                        if (locationMarker) locationMarker.remove();
                        locationMarker = L.marker([loc.lat, loc.lon]).addTo(locationMap);
                    }
                    updateSaveFavoriteButton();
                });

                list.appendChild(chip);
            });
        }

        function updateSaveFavoriteButton() {
            const btn = document.getElementById('save-favorite-btn');
            if (!selectedLocation) {
                btn.disabled = true;
                btn.innerHTML = '&#9734; Save';
                btn.classList.remove('saved');
                return;
            }
            btn.disabled = false;
            if (isLocationSaved(selectedLocation)) {
                btn.innerHTML = '&#9733; Saved';
                btn.classList.add('saved');
            } else {
                btn.innerHTML = '&#9734; Save';
                btn.classList.remove('saved');
            }
        }

        function updatePanelLocations() {
            document.querySelectorAll('.panel-location').forEach(el => {
                el.textContent = currentLocation.name;
            });
        }

        // Sync header display with initial location on load
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('location-name').textContent = currentLocation.name;
            document.getElementById('display-lat').textContent = currentLocation.lat.toFixed(2);
            document.getElementById('display-lon').textContent = currentLocation.lon.toFixed(2);
            updatePanelLocations();
        });

        updatePanelLocations();

        // Location selector map initialization
        function initLocationMap() {
            locationMap = L.map('location-map').setView([20, 0], 2);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                maxZoom: 19
            }).addTo(locationMap);

            // Add click handler
            locationMap.on('click', function(e) {
                const lat = e.latlng.lat;
                const lon = e.latlng.lng;

                // Remove existing marker
                if (locationMarker) {
                    locationMap.removeLayer(locationMarker);
                }

                // Add new marker
                locationMarker = L.marker([lat, lon]).addTo(locationMap);

                selectedLocation = { lat: lat, lon: lon };
                document.getElementById('confirm-location-btn').disabled = false;
                document.getElementById('save-favorite-btn').disabled = false;
                updateSaveFavoriteButton();

                // Reverse geocode to get location name
                fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`)
                    .then(response => response.json())
                    .then(data => {
                        let name = 'Unknown Location';
                        if (data.address) {
                            const addr = data.address;
                            const parts = [];
                            if (addr.city) parts.push(addr.city);
                            else if (addr.town) parts.push(addr.town);
                            else if (addr.village) parts.push(addr.village);
                            else if (addr.county) parts.push(addr.county);

                            if (addr.state) parts.push(addr.state);
                            else if (addr.region) parts.push(addr.region);

                            if (addr.country) parts.push(addr.country);

                            if (parts.length > 0) {
                                name = parts.join(', ');
                            } else if (data.display_name) {
                                name = data.display_name.split(',').slice(0, 3).join(',');
                            }
                        }
                        selectedLocation.name = name;
                        document.getElementById('selected-location-text').textContent = `${name} (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
                    })
                    .catch(() => {
                        selectedLocation.name = `Location (${lat.toFixed(2)}, ${lon.toFixed(2)})`;
                        document.getElementById('selected-location-text').textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                    });
            });

            // Location search handler
            function searchLocation(query) {
                if (!query.trim()) return;
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query.trim())}&limit=1`)
                    .then(r => r.json())
                    .then(results => {
                        if (!results || results.length === 0) {
                            document.getElementById('selected-location-text').textContent = 'No results found';
                            return;
                        }
                        const lat = parseFloat(results[0].lat);
                        const lon = parseFloat(results[0].lon);
                        const name = results[0].display_name.split(',').slice(0, 3).join(',').trim();

                        locationMap.flyTo([lat, lon], 10);

                        if (locationMarker) locationMarker.remove();
                        locationMarker = L.marker([lat, lon]).addTo(locationMap);

                        selectedLocation = { lat, lon, name };
                        document.getElementById('selected-location-text').textContent = `${name} (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
                        document.getElementById('confirm-location-btn').disabled = false;
                        document.getElementById('save-favorite-btn').disabled = false;
                        updateSaveFavoriteButton();
                    })
                    .catch(() => {});
            }

            document.getElementById('location-search-btn').addEventListener('click', () => {
                searchLocation(document.getElementById('location-search-input').value);
            });

            document.getElementById('location-search-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    searchLocation(e.target.value);
                }
            });
        }

        // Confirm location button
        document.addEventListener('DOMContentLoaded', function() {
            const confirmBtn = document.getElementById('confirm-location-btn');

            confirmBtn.addEventListener('click', function() {
                if (selectedLocation) {
                    currentLocation = { ...selectedLocation };

                    // Persist last location
                    localStorage.setItem('last-location', JSON.stringify(currentLocation));

                    // Update display
                    document.getElementById('location-name').textContent = currentLocation.name;
                    updatePanelLocations();
                    document.getElementById('display-lat').textContent = currentLocation.lat.toFixed(2);
                    document.getElementById('display-lon').textContent = currentLocation.lon.toFixed(2);

                    // Close modal
                    closeModal();

                    // Reload all data
                    reloadAllData();
                }
            });

            // Save favorite button
            document.getElementById('save-favorite-btn').addEventListener('click', function() {
                if (!selectedLocation) return;
                if (isLocationSaved(selectedLocation)) {
                    // Remove it
                    const locations = getSavedLocations();
                    const roundedLat = parseFloat(selectedLocation.lat.toFixed(4));
                    const roundedLon = parseFloat(selectedLocation.lon.toFixed(4));
                    const idx = locations.findIndex(l =>
                        parseFloat(l.lat.toFixed(4)) === roundedLat &&
                        parseFloat(l.lon.toFixed(4)) === roundedLon
                    );
                    if (idx !== -1) removeSavedLocation(idx);
                } else {
                    const result = addSavedLocation(selectedLocation);
                    if (result === null) {
                        // At capacity  show toast
                        const toast = document.getElementById('share-toast');
                        toast.textContent = 'Maximum 10 saved locations';
                        toast.classList.add('show');
                        setTimeout(function() {
                            toast.classList.remove('show');
                            toast.textContent = 'Link copied to clipboard';
                        }, 2000);
                        return;
                    }
                }
                renderFavoritesList();
                updateSaveFavoriteButton();
            });
        });

        // Function to reload all dashboard data
        function reloadAllData() {
            // Stop slider animation on location change
            stopSliderPlay();
            // Destroy existing cam streams
            destroyCam(0);
            destroyCam(1);

            // Reset shared time ranges and map data
            waveTimeRange = null;
            tideTimeRange = null;
            basinGridData = null;
            localGridData = null;
            // Reset rect caches and lazy render state
            basinRectangles = [];
            basinRectsBuilt = false;
            basinRectsLayerType = null;
            localPeriodRects = [];
            localHeightRects = [];
            localWindMarkers = [];
            localRectsBuilt = false;
            basinDataReady = false;
            localDataReady = false;
            basinRendered = false;
            localRendered = false;
            // Show loading state on maps (skip buoy map  managed separately)
            document.querySelectorAll('.map-container:not(.buoy-map)').forEach(el => {
                el.innerHTML = '<div class="map-loading">Loading data for new location...</div>';
            });
            // Show loading state on current conditions
            document.getElementById('current-conditions-stats').style.display = 'none';
            document.getElementById('current-conditions-error').style.display = '';
            document.getElementById('current-conditions-error').textContent = 'Loading conditions...';
            // Show loading state on buoy panel (full-pane overlay)
            document.getElementById('buoy-badge').textContent = 'Loading';
            showBuoyLoading();
            // Show loading state on charts and daylight table
            showChartUnavailable('waveChart', 'Loading forecast...');
            showChartUnavailable('tideChart', 'Loading tides...');
            document.getElementById('forecast-table').innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--text-muted);padding:16px">Loading forecast...</td></tr>';

            // Reload lightweight endpoints in parallel
            loadPointForecast();
            loadTideData();
            loadNearestCams();
            loadBuoyData();
            // Reload heavy grid endpoints sequentially to avoid rate limits
            loadOceanBasinMaps().then(() => loadLocalMaps());
        }

        // Point data and main chart script
        let waveChart = null;

        function loadPointForecast() {
            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            fetch(`/api/forecast?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('API Error (Point Data):', data.error);
                        showChartUnavailable('waveChart', 'Forecast data unavailable');
                        document.getElementById('current-conditions-stats').style.display = 'none';
                        document.getElementById('current-conditions-error').textContent = 'Conditions data unavailable';
                        document.getElementById('current-conditions-error').style.display = '';
                        return;
                    }
                    clearChartUnavailable('waveChart');
                    document.getElementById('current-conditions-stats').style.display = '';
                    document.getElementById('current-conditions-error').style.display = 'none';
                    const current = data[0];
                    document.getElementById('current_wave_height').textContent = `${(current.wave_height * M_TO_FT).toFixed(1)} ft`;
                    document.getElementById('current_wave_period').textContent = `${current.wave_period.toFixed(2)} s`;
                    document.getElementById('current_wave_direction').textContent = `${current.wave_direction.toFixed(0)} `;
                    // Wind (km/h  mph)
                    const KMH_TO_MPH = 0.621371;
                    document.getElementById('current_wind_speed').textContent = current.wind_speed != null ? `${(current.wind_speed * KMH_TO_MPH).toFixed(0)} mph` : '-';
                    const windDirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
                    document.getElementById('current_wind_direction').textContent = current.wind_direction != null ? `${windDirs[Math.round(current.wind_direction / 22.5) % 16]} (${current.wind_direction.toFixed(0)})` : '-';
                    // Temperatures (CF)
                    const airC = current.air_temperature;
                    const waterC = current.water_temperature;
                    document.getElementById('current_air_temp').textContent = airC != null ? `${(airC * 9/5 + 32).toFixed(0)} F` : '-';
                    document.getElementById('current_water_temp').textContent = waterC != null ? `${(waterC * 9/5 + 32).toFixed(0)} F` : '-';
                    const tableBody = document.getElementById('forecast-table');
                    tableBody.innerHTML = '';

                    // Helper to convert wind direction to compass
                    function degToCompass(deg) {
                        if (deg === null || deg === undefined) return '-';
                        const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                        return dirs[Math.round(deg / 22.5) % 16];
                    }

                    // Check if wind is offshore (good for surfing)
                    const OFFSHORE_DIRECTION = 315;
                    const OFFSHORE_TOLERANCE = 45;
                    const CALM_WIND_THRESHOLD = 5;

                    function isOffshoreWind(windDirection, windSpeed) {
                        if (windSpeed !== null && windSpeed < CALM_WIND_THRESHOLD) {
                            return true;
                        }

                        if (windDirection === null || windDirection === undefined) {
                            return false;
                        }

                        let diff = Math.abs(windDirection - OFFSHORE_DIRECTION);
                        if (diff > 180) diff = 360 - diff;

                        return diff <= OFFSHORE_TOLERANCE;
                    }

                    // Filter to 5am-9pm and sample every 3 hours
                    let lastShownHour = -999;
                    data.forEach((item, index) => {
                        const itemTime = new Date(item.time);
                        const hour = itemTime.getHours();

                        if (hour < 5 || hour > 21) {
                            return;
                        }

                        if (hour % 3 !== 0) {
                            return;
                        }

                        const dayHourKey = itemTime.toDateString() + '-' + hour;
                        if (lastShownHour === dayHourKey) {
                            return;
                        }
                        lastShownHour = dayHourKey;

                        const dateStr = itemTime.toLocaleDateString([], {weekday: 'short', month: 'short', day: 'numeric'});
                        const timeStr = itemTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: true});
                        const windDir = item.wind_direction !== null ? `${degToCompass(item.wind_direction)} (${item.wind_direction.toFixed(0)})` : '-';
                        const windSpeed = item.wind_speed !== null ? (item.wind_speed * KMH_TO_MPH).toFixed(1) : '-';

                        const offshore = isOffshoreWind(item.wind_direction, item.wind_speed);
                        const rowClass = offshore ? 'row-good' : '';
                        const offshoreIndicator = offshore ? ' &#10003;' : '';

                        const row = `<tr class="${rowClass}">
                            <td>${dateStr}</td>
                            <td>${timeStr}</td>
                            <td>${(item.wave_height * M_TO_FT).toFixed(1)}</td>
                            <td>${item.wave_period.toFixed(1)}</td>
                            <td>${windSpeed}</td>
                            <td>${windDir}${offshoreIndicator}</td>
                        </tr>`;
                        tableBody.innerHTML += row;
                    });
                    const ctx = document.getElementById('waveChart').getContext('2d');

                    // Store wind directions for the custom plugin
                    const windDirections = data.map(item => item.wind_direction);

                    // Custom plugin to draw wind direction arrows
                    const windArrowPlugin = {
                        id: 'windArrows',
                        afterDatasetsDraw(chart) {
                            const meta = chart.getDatasetMeta(2);
                            if (!meta.visible) return;

                            const ctx = chart.ctx;
                            meta.data.forEach((point, index) => {
                                const direction = windDirections[index];
                                if (direction === null || direction === undefined) return;

                                const x = point.x;
                                const y = point.y;
                                const size = 8;

                                const radians = ((direction + 180) % 360) * Math.PI / 180;

                                ctx.save();
                                ctx.translate(x, y);
                                ctx.rotate(radians);

                                ctx.beginPath();
                                ctx.moveTo(0, -size);
                                ctx.lineTo(-size * 0.5, size * 0.5);
                                ctx.lineTo(0, size * 0.2);
                                ctx.lineTo(size * 0.5, size * 0.5);
                                ctx.closePath();

                                ctx.fillStyle = 'rgba(255, 206, 86, 0.9)';
                                ctx.fill();
                                ctx.strokeStyle = 'rgba(200, 160, 60, 1)';
                                ctx.lineWidth = 1;
                                ctx.stroke();

                                ctx.restore();
                            });
                        }
                    };

                    // Destroy existing chart if it exists
                    // Compute time range for sync
                    const waveTimes = data.map(item => new Date(item.time));
                    waveTimeRange = { min: waveTimes[0], max: waveTimes[waveTimes.length - 1] };

                    if (waveChart) {
                        waveChart.destroy();
                    }

                    waveChart = new Chart(ctx, {
                        type: 'line',
                        plugins: [windArrowPlugin],
                        data: {
                            datasets: [
                                {
                                    label: 'Total Wave Height (ft)',
                                    data: data.map(item => ({ x: new Date(item.time), y: item.wave_height * M_TO_FT })),
                                    borderColor: 'rgb(75, 192, 192)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    tension: 0.1,
                                    yAxisID: 'y',
                                    pointRadius: 2
                                },
                                {
                                    label: 'Wind Wave Height (ft)',
                                    data: data.map(item => ({ x: new Date(item.time), y: item.wind_wave_height * M_TO_FT })),
                                    borderColor: 'rgb(255, 99, 132)',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    tension: 0.1,
                                    yAxisID: 'y',
                                    pointRadius: 2
                                },
                                {
                                    label: 'Wind Speed (mph)',
                                    data: data.map(item => ({ x: new Date(item.time), y: item.wind_speed * KMH_TO_MPH })),
                                    borderColor: 'rgb(255, 206, 86)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    tension: 0.1,
                                    yAxisID: 'y1',
                                    pointRadius: 0,
                                    borderWidth: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            hour: 'MMM d HH:mm'
                                        },
                                        tooltipFormat: 'MMM d, yyyy HH:mm'
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 45,
                                        autoSkip: true,
                                        maxTicksLimit: 24,
                                        color: '#888'
                                    },
                                    grid: {
                                        color: 'rgba(42, 42, 42, 0.8)'
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    position: 'left',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Wave Height (ft)',
                                        color: 'rgb(75, 192, 192)'
                                    },
                                    ticks: {
                                        color: 'rgb(75, 192, 192)'
                                    },
                                    grid: {
                                        color: 'rgba(75, 192, 192, 0.15)'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    position: 'right',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Wind Speed (mph)',
                                        color: 'rgb(255, 206, 86)'
                                    },
                                    ticks: {
                                        color: 'rgb(255, 206, 86)'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    labels: { color: '#888' }
                                },
                                tooltip: {
                                    callbacks: {
                                        afterBody: function(context) {
                                            const index = context[0].dataIndex;
                                            const dir = windDirections[index];
                                            if (dir !== null && dir !== undefined) {
                                                return `Wind Direction: ${dir.toFixed(0)}`;
                                            }
                                            return '';
                                        }
                                    }
                                },
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x'
                                    },
                                    zoom: {
                                        wheel: { enabled: true },
                                        pinch: { enabled: true },
                                        mode: 'x',
                                        onZoomComplete: () => document.getElementById('wave-chart-reset').style.display = ''
                                    }
                                }
                            }
                        }
                    });

                    syncChartTimeAxes();
                })
                .catch(error => {
                    console.error('Error fetching point forecast data:', error);
                    showChartUnavailable('waveChart', 'Forecast data unavailable');
                    document.getElementById('current-conditions-stats').style.display = 'none';
                    document.getElementById('current-conditions-error').textContent = 'Conditions data unavailable';
                    document.getElementById('current-conditions-error').style.display = '';
                });
        }

        // Initial load  stagger heavy API calls to avoid rate limits
        // Point forecast + tides are lightweight (single-point), load first in parallel.
        // Basin and local grids are heavy (hundreds of points), load sequentially after.
        document.addEventListener('DOMContentLoaded', function() {
            loadPointForecast();
            loadTideData();
            loadBuoyData();
            loadOceanBasinMaps().then(() => loadLocalMaps());
        });

        // Ocean Basin map script
        let mapBasin = null;
        let basinGridLayer = null;
        let basinVelocityLayer = null;
        let basinLegendControl = null;

        // Basin layer dropdown menu
        function toggleBasinLayerMenu(e) {
            e.stopPropagation();
            const dropdown = document.getElementById('basin-layer-dropdown');
            dropdown.classList.toggle('open');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('basin-layer-dropdown');
            if (dropdown && !e.target.closest('.basin-layer-menu')) {
                dropdown.classList.remove('open');
            }
        });

        function getBasinLayerState() {
            return {
                height: document.getElementById('basin-layer-height').checked,
                period: document.getElementById('basin-layer-period').checked,
                direction: document.getElementById('basin-layer-direction').checked,
                wind: document.getElementById('basin-layer-wind').checked
            };
        }

        function onBasinLayerToggle(source) {
            const heightCb = document.getElementById('basin-layer-height');
            const periodCb = document.getElementById('basin-layer-period');
            const directionCb = document.getElementById('basin-layer-direction');

            // Wave height, period, and direction are mutually exclusive colored grids
            if (source === 'height' && heightCb.checked) {
                periodCb.checked = false;
                directionCb.checked = false;
            } else if (source === 'period' && periodCb.checked) {
                heightCb.checked = false;
                directionCb.checked = false;
            } else if (source === 'direction' && directionCb.checked) {
                heightCb.checked = false;
                periodCb.checked = false;
            }

            // Re-render with current slider time (force rebuild since layer type changed)
            const slider = document.getElementById('time-slider');
            const timeIndex = parseInt(slider.value) || 0;
            updateBasinMap(timeIndex, true);
        }

        function getColorForDirection(deg) {
            // Map compass bearing to HSL hue wheel  gives intuitive directional coloring
            return `hsl(${deg % 360}, 75%, 50%)`;
        }

        function compassLabel(deg) {
            const dirs = ['N','NE','E','SE','S','SW','W','NW'];
            return dirs[Math.round(deg / 45) % 8];
        }

        function updateBasinLegend() {
            if (!mapBasin) return;
            if (basinLegendControl) {
                mapBasin.removeControl(basinLegendControl);
                basinLegendControl = null;
            }
            const state = getBasinLayerState();

            if (state.direction) {
                // Compass direction legend
                basinLegendControl = L.control({position: 'bottomright'});
                basinLegendControl.onAdd = function() {
                    const div = L.DomUtil.create('div', 'legend');
                    div.innerHTML = '<strong>Direction (from)</strong><br>';
                    const entries = [
                        {deg: 0, label: 'N'}, {deg: 45, label: 'NE'},
                        {deg: 90, label: 'E'}, {deg: 135, label: 'SE'},
                        {deg: 180, label: 'S'}, {deg: 225, label: 'SW'},
                        {deg: 270, label: 'W'}, {deg: 315, label: 'NW'}
                    ];
                    entries.forEach(e => {
                        div.innerHTML += `<span class="legend-color" style="background:${getColorForDirection(e.deg)}"></span>${e.label}<br>`;
                    });
                    return div;
                };
                basinLegendControl.addTo(mapBasin);
                return;
            }

            let title, minVal, maxVal;
            if (state.height) {
                title = 'Height (ft)'; minVal = 0; maxVal = 20;
            } else if (state.period) {
                title = 'Period (s)'; minVal = 0; maxVal = 15;
            } else {
                return;
            }
            basinLegendControl = L.control({position: 'bottomright'});
            basinLegendControl.onAdd = function() {
                const div = L.DomUtil.create('div', 'legend');
                const colors = ['blue', 'cyan', 'lime', 'yellow', 'red'];
                div.innerHTML = `<strong>${title}</strong><br>`;
                colors.forEach((color, i) => {
                    const val = minVal + (maxVal - minVal) * i / (colors.length - 1);
                    div.innerHTML += `<span class="legend-color" style="background:${color}"></span>${val.toFixed(1)}<br>`;
                });
                return div;
            };
            basinLegendControl.addTo(mapBasin);
        }

        function buildVelocityData(timeIndex) {
            if (!basinGridData || !basinGridData.wind_speed) return null;
            const lats = basinGridData.lats;
            const lons = basinGridData.lons;
            const bTimeIndex = Math.min(timeIndex, basinGridData.times.length - 1);
            const nx = lons.length;
            const ny = lats.length;
            const lo1 = lons[0];
            const lo2 = lons[lons.length - 1];
            const la1 = lats[lats.length - 1]; // north (data north-to-south for velocity)
            const la2 = lats[0]; // south
            const dx = lons.length > 1 ? Math.abs(lons[1] - lons[0]) : 1.5;
            const dy = lats.length > 1 ? Math.abs(lats[1] - lats[0]) : 1.5;

            const uData = [];
            const vData = [];
            // leaflet-velocity expects north-to-south row order; our lats are south-to-north
            for (let i = lats.length - 1; i >= 0; i--) {
                for (let j = 0; j < lons.length; j++) {
                    const speedKmh = basinGridData.wind_speed[bTimeIndex][i][j];
                    const dir = basinGridData.wind_direction[bTimeIndex][i][j];
                    const speedMs = speedKmh / 3.6;
                    const dirRad = dir * Math.PI / 180;
                    uData.push(-speedMs * Math.sin(dirRad));
                    vData.push(-speedMs * Math.cos(dirRad));
                }
            }

            const header = {
                parameterCategory: 2,
                parameterNumber: 2,
                lo1: lo1, lo2: lo2, la1: la1, la2: la2,
                dx: dx, dy: dy, nx: nx, ny: ny
            };

            return [
                { header: Object.assign({}, header, { parameterNumber: 2 }), data: uData },
                { header: Object.assign({}, header, { parameterNumber: 3 }), data: vData }
            ];
        }

        function updateBasinVelocityLayer(timeIndex) {
            if (!mapBasin) return;
            const state = getBasinLayerState();

            if (!state.wind) {
                if (basinVelocityLayer) {
                    mapBasin.removeLayer(basinVelocityLayer);
                    basinVelocityLayer = null;
                }
                return;
            }

            const velocityData = buildVelocityData(timeIndex);
            if (!velocityData) return;

            if (basinVelocityLayer) {
                basinVelocityLayer.setData(velocityData);
            } else {
                basinVelocityLayer = L.velocityLayer({
                    displayValues: true,
                    displayOptions: {
                        velocityType: 'Wind',
                        displayPosition: 'bottomleft',
                        displayEmptyString: 'No wind data'
                    },
                    data: velocityData,
                    maxVelocity: 25,
                    velocityScale: 0.01,
                    particleAge: 60,
                    lineWidth: 1.5,
                    particleMultiplier: 1/200,
                    colorScale: [
                        'rgba(255,255,255,0.2)',
                        'rgba(255,255,255,0.35)',
                        'rgba(255,255,255,0.5)',
                        'rgba(200,200,255,0.6)',
                        'rgba(150,200,255,0.7)',
                        'rgba(100,180,255,0.8)'
                    ]
                });
                basinVelocityLayer.addTo(mapBasin);
            }
        }

        // Track which basin layer type was used for cached rects (force rebuild on toggle)
        let basinRectsLayerType = null;

        function updateBasinMap(timeIndex, forceRebuild) {
            if (!basinGridData || !mapBasin) return;

            const state = getBasinLayerState();
            const activeType = state.height ? 'height' : state.period ? 'period' : state.direction ? 'direction' : null;

            // Detect layer type change  must rebuild
            if (activeType !== basinRectsLayerType) forceRebuild = true;

            // Remove old layer if rebuilding
            if (forceRebuild || !activeType) {
                if (basinGridLayer) {
                    mapBasin.removeLayer(basinGridLayer);
                    basinGridLayer = null;
                }
                basinRectangles = [];
                basinRectsBuilt = false;
                basinRectsLayerType = activeType;
            }

            if (!activeType) {
                updateBasinLegend();
                updateBasinVelocityLayer(timeIndex);
                return;
            }

            const bLats = basinGridData.lats;
            const bLons = basinGridData.lons;
            const basinRes = bLats.length > 1 ? Math.abs(bLats[1] - bLats[0]) : 6;
            const bHalfRes = basinRes / 2;
            const bTimeIndex = Math.min(timeIndex, basinGridData.times.length - 1);

            // Fast path: reuse existing rectangles, just update style + popup
            if (basinRectsBuilt && basinRectangles.length > 0) {
                for (const entry of basinRectangles) {
                    const {rect, i, j} = entry;
                    let color, popup;
                    if (state.height) {
                        const wh = basinGridData.wave_height[bTimeIndex][i][j];
                        color = getColorForValue(wh, 0, 6);
                        popup = `Wave Height: ${(wh * M_TO_FT).toFixed(1)} ft`;
                    } else if (state.period) {
                        const wp = basinGridData.wave_period[bTimeIndex][i][j];
                        color = getColorForValue(wp, 0, 15);
                        popup = `Wave Period: ${wp.toFixed(1)} s`;
                    } else {
                        const dir = basinGridData.wave_direction[bTimeIndex][i][j];
                        color = getColorForDirection(dir);
                        popup = `Wave Direction: ${dir.toFixed(0)} (${compassLabel(dir)})`;
                    }
                    rect.setStyle({fillColor: color, color: color});
                    rect.setPopupContent(popup);
                }
                updateBasinLegend();
                updateBasinVelocityLayer(timeIndex);
                return;
            }

            // Slow path: first render  build descriptors then batch-create
            basinGridLayer = L.layerGroup();
            const basinRenderer = L.canvas({ padding: 0.5, oceanClip: true });
            basinRectangles = [];
            const descriptors = [];

            for (let i = 0; i < bLats.length; i++) {
                for (let j = 0; j < bLons.length; j++) {
                    const lat = bLats[i];
                    const lon = bLons[j];
                    const bounds = [[lat - bHalfRes, lon - bHalfRes], [lat + bHalfRes, lon + bHalfRes]];
                    let color, popup, hasData = false;

                    if (state.height) {
                        const wh = basinGridData.wave_height[bTimeIndex][i][j];
                        if (wh > 0) { color = getColorForValue(wh, 0, 6); popup = `Wave Height: ${(wh * M_TO_FT).toFixed(1)} ft`; hasData = true; }
                    } else if (state.period) {
                        const wp = basinGridData.wave_period[bTimeIndex][i][j];
                        if (wp > 0) { color = getColorForValue(wp, 0, 15); popup = `Wave Period: ${wp.toFixed(1)} s`; hasData = true; }
                    } else if (state.direction) {
                        const dir = basinGridData.wave_direction[bTimeIndex][i][j];
                        const wh = basinGridData.wave_height[bTimeIndex][i][j];
                        if (dir > 0 || wh > 0) { color = getColorForDirection(dir); popup = `Wave Direction: ${dir.toFixed(0)} (${compassLabel(dir)})`; hasData = true; }
                    }

                    if (hasData) {
                        descriptors.push({
                            type: 'rect', bounds, i, j, popup,
                            options: {renderer: basinRenderer, color, weight: 0, fillColor: color, fillOpacity: 0.7},
                            store: basinRectangles
                        });
                    }
                }
            }

            batchGeneration++;
            batchAddLayers(descriptors, basinGridLayer, mapBasin, batchGeneration, () => {
                basinRectsBuilt = true;
            });

            // Update legend and velocity immediately (they're lightweight)
            updateBasinLegend();
            updateBasinVelocityLayer(timeIndex);
        }

        // Render the basin map (called after data fetch, deferred by IntersectionObserver)
        function renderBasinMap() {
            if (!basinGridData || basinRendered) return;
            basinRendered = true;

            const data = basinGridData;
            const center = data.center;

            // Clear loading message
            document.getElementById('map-basin').innerHTML = '';

            // Initialize map centered on the forecast location (zoom 3 for global view)
            mapBasin = L.map('map-basin', {worldCopyJump: true}).setView([center.lat, center.lon], 3);

            addHomeButton(mapBasin, [center.lat, center.lon], 3);

            const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
            const tileLayerOptions = {
                attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                maxZoom: 10
            };

            L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(mapBasin);

            // Add marker for forecast location
            const locationIcon = L.divIcon({
                html: '<div style="color: #ff0; font-size: 20px; text-shadow: 2px 2px 4px black;">&#9733;</div>',
                className: 'location-marker',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            L.marker([center.lat, center.lon], {icon: locationIcon}).addTo(mapBasin).bindPopup(currentLocation.name);

            setTimeout(() => {
                mapBasin.invalidateSize();
            }, 100);

            // Notify unified slider
            onMapDataReady();
        }

        function loadOceanBasinMaps() {
            // Clear existing map
            if (mapBasin) {
                mapBasin.remove();
                mapBasin = null;
            }
            basinGridLayer = null;
            basinVelocityLayer = null;
            basinLegendControl = null;
            basinRectangles = [];
            basinRectsBuilt = false;
            basinRectsLayerType = null;
            basinDataReady = false;
            basinRendered = false;

            // Reset container HTML
            document.getElementById('map-basin').innerHTML = '<div class="map-loading">Loading ocean data...</div>';

            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            return fetch(`/api/ocean-basin?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('API Error (Basin Data):', data.error);
                        const center = [currentLocation.lat, currentLocation.lon];
                        mapBasin = initEmptyMap('map-basin', center, 3, 'Ocean data unavailable');
                        return;
                    }

                    // Store data globally
                    basinGridData = data;
                    basinDataReady = true;

                    // If container is already visible, render immediately
                    if (mapVisibility['map-basin']) {
                        renderBasinMap();
                    }
                    // Otherwise IntersectionObserver will trigger renderBasinMap when visible
                })
                .catch(error => {
                    console.error('Error fetching ocean basin data:', error);
                    const center = [currentLocation.lat, currentLocation.lon];
                    mapBasin = initEmptyMap('map-basin', center, 3, 'Ocean data unavailable');
                });
        }

        // Basin maps loaded via staggered init in loadPointForecast listener

        // Local map data and animation script
        let map1 = null, map2 = null, map3 = null;
        let localWavePeriodLayer = null, localWaveHeightLayer = null, localWindLayer = null;

        // Render local maps (called after data fetch, deferred by IntersectionObserver)
        function renderLocalMaps() {
            if (!localGridData || localRendered) return;
            localRendered = true;

            const mapContainers = ['map-wave-period', 'map-wave-height', 'map-wind'];
            const gridData = localGridData;

            const lats = gridData.lats;
            const lons = gridData.lons;

            const centerLat = (lats[0] + lats[lats.length - 1]) / 2;
            const centerLon = (lons[0] + lons[lons.length - 1]) / 2;

            // Clear loading messages
            mapContainers.forEach(id => {
                document.getElementById(id).innerHTML = '';
            });

            // Initialize maps
            map1 = L.map('map-wave-period').setView([centerLat, centerLon], 8);
            map2 = L.map('map-wave-height').setView([centerLat, centerLon], 8);
            map3 = L.map('map-wind').setView([centerLat, centerLon], 8);

            addHomeButton(map1, [centerLat, centerLon], 8);
            addHomeButton(map2, [centerLat, centerLon], 8);
            addHomeButton(map3, [centerLat, centerLon], 8);

            const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
            const tileLayerOptions = {
                attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                maxZoom: 19
            };

            L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map1);
            L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map2);
            L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map3);

            setTimeout(() => {
                map1.invalidateSize();
                map2.invalidateSize();
                map3.invalidateSize();
            }, 100);

            // Add legends
            function addLegend(map, title, minVal, maxVal, colors) {
                const legend = L.control({position: 'bottomright'});
                legend.onAdd = function() {
                    const div = L.DomUtil.create('div', 'legend');
                    div.innerHTML = `<strong>${title}</strong><br>`;
                    colors.forEach((color, i) => {
                        const val = minVal + (maxVal - minVal) * i / (colors.length - 1);
                        div.innerHTML += `<span class="legend-color" style="background:${color}"></span>${val.toFixed(1)}<br>`;
                    });
                    return div;
                };
                legend.addTo(map);
            }

            addLegend(map1, 'Period (s)', 0, 15, ['#00f', '#0ff', '#0f0', '#ff0', '#f00']);
            addLegend(map2, 'Height (ft)', 0, 10, ['#00f', '#0ff', '#0f0', '#ff0', '#f00']);

            // Wind legend
            const windLegend = L.control({position: 'bottomright'});
            windLegend.onAdd = function() {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = '<strong>Wind (mph)</strong><br>' +
                    '<span style="color:#33ff88">&rarr;</span> 0-6<br>' +
                    '<span style="color:#3388ff">&rarr;</span> 6-12<br>' +
                    '<span style="color:#ffff33">&rarr;</span> 12-19<br>' +
                    '<span style="color:#ff8833">&rarr;</span> 19+';
                return div;
            };
            windLegend.addTo(map3);

            // Notify unified slider
            onMapDataReady();
        }

        function loadLocalMaps() {
            const mapContainers = ['map-wave-period', 'map-wave-height', 'map-wind'];

            // Clear existing maps
            if (map1) { map1.remove(); map1 = null; }
            if (map2) { map2.remove(); map2 = null; }
            if (map3) { map3.remove(); map3 = null; }
            localWavePeriodLayer = null;
            localWaveHeightLayer = null;
            localWindLayer = null;
            localPeriodRects = [];
            localHeightRects = [];
            localWindMarkers = [];
            localRectsBuilt = false;
            localDataReady = false;
            localRendered = false;

            // Reset container HTML
            mapContainers.forEach(id => {
                document.getElementById(id).innerHTML = '<div class="map-loading">Loading map data...</div>';
            });

            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            return fetch(`/api/map-forecast?${params}`)
                .then(response => response.json())
                .then(gridData => {
                    if (gridData.error) {
                        console.error('API Error (Map Data):', gridData.error);
                        const center = [currentLocation.lat, currentLocation.lon];
                        map1 = initEmptyMap('map-wave-period', center, 8, 'Forecast data unavailable');
                        map2 = initEmptyMap('map-wave-height', center, 8, 'Forecast data unavailable');
                        map3 = initEmptyMap('map-wind', center, 8, 'Forecast data unavailable');
                        return;
                    }

                    if (!gridData.lats || !gridData.lons || !gridData.times || !gridData.wave_height || !gridData.wave_period || !gridData.wind_speed || !gridData.wind_direction) {
                        console.error("Invalid gridData structure:", gridData);
                        const center = [currentLocation.lat, currentLocation.lon];
                        map1 = initEmptyMap('map-wave-period', center, 8, 'Invalid data structure');
                        map2 = initEmptyMap('map-wave-height', center, 8, 'Invalid data structure');
                        map3 = initEmptyMap('map-wind', center, 8, 'Invalid data structure');
                        return;
                    }

                    // Store data globally
                    localGridData = gridData;
                    localDataReady = true;

                    // If any local map container is already visible, render immediately
                    if (mapVisibility['map-wave-height'] || mapVisibility['map-wind'] || mapVisibility['map-wave-period']) {
                        renderLocalMaps();
                    }
                    // Otherwise IntersectionObserver will trigger renderLocalMaps when visible
                })
                .catch(error => {
                    console.error('Error fetching map forecast data:', error);
                    const center = [currentLocation.lat, currentLocation.lon];
                    map1 = initEmptyMap('map-wave-period', center, 8, 'Forecast data unavailable');
                    map2 = initEmptyMap('map-wave-height', center, 8, 'Forecast data unavailable');
                    map3 = initEmptyMap('map-wind', center, 8, 'Forecast data unavailable');
                });
        }

        // === Unified Map Time Slider Logic ===

        // Batch utility: creates Leaflet layers in chunks of BATCH_SIZE, yielding
        // to the browser via requestAnimationFrame between batches so HLS.js can decode.
        const BATCH_SIZE = 200;
        function batchAddLayers(descriptors, layerGroup, map, gen, callback) {
            let idx = 0;
            function processChunk() {
                if (gen !== batchGeneration) return; // cancelled by newer batch
                const end = Math.min(idx + BATCH_SIZE, descriptors.length);
                for (; idx < end; idx++) {
                    const d = descriptors[idx];
                    if (d.type === 'rect') {
                        const rect = L.rectangle(d.bounds, d.options);
                        if (d.popup) rect.bindPopup(d.popup);
                        rect.addTo(layerGroup);
                        if (d.store) d.store.push({rect, i: d.i, j: d.j});
                    } else if (d.type === 'marker') {
                        const marker = L.marker(d.latlng, {icon: d.icon});
                        if (d.popup) marker.bindPopup(d.popup);
                        marker.addTo(layerGroup);
                        if (d.store) d.store.push({marker, i: d.i, j: d.j, arrowDiv: d.arrowDiv});
                    }
                }
                if (idx < descriptors.length) {
                    requestAnimationFrame(processChunk);
                } else {
                    if (!map.hasLayer(layerGroup)) layerGroup.addTo(map);
                    if (callback) callback();
                }
            }
            if (!map.hasLayer(layerGroup)) layerGroup.addTo(map);
            requestAnimationFrame(processChunk);
        }

        function getColorForValue(value, minVal, maxVal) {
            const ratio = Math.min(1, Math.max(0, (value - minVal) / (maxVal - minVal)));
            const stops = [
                {pos: 0, r: 0, g: 0, b: 255},
                {pos: 0.25, r: 0, g: 255, b: 255},
                {pos: 0.5, r: 0, g: 255, b: 0},
                {pos: 0.75, r: 255, g: 255, b: 0},
                {pos: 1, r: 255, g: 0, b: 0}
            ];

            let lower = stops[0], upper = stops[stops.length - 1];
            for (let i = 0; i < stops.length - 1; i++) {
                if (ratio >= stops[i].pos && ratio <= stops[i + 1].pos) {
                    lower = stops[i];
                    upper = stops[i + 1];
                    break;
                }
            }

            const range = upper.pos - lower.pos;
            const t = range === 0 ? 0 : (ratio - lower.pos) / range;
            const r = Math.round(lower.r + t * (upper.r - lower.r));
            const g = Math.round(lower.g + t * (upper.g - lower.g));
            const b = Math.round(lower.b + t * (upper.b - lower.b));

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getWindColor(speed) {
            if (speed < 10) return '#33ff88';
            if (speed < 20) return '#3388ff';
            if (speed < 30) return '#ffff33';
            return '#ff8833';
        }

        function onMapDataReady() {
            // Determine time array from whichever dataset is available
            const times = (localGridData && localGridData.times) || (basinGridData && basinGridData.times);
            if (!times) return;

            const slider = document.getElementById('time-slider');
            slider.max = times.length - 1;
            slider.value = 0;
            updateAllMaps(0);
        }

        function updateAllMaps(timeIndex) {
            // Determine time array
            const times = (localGridData && localGridData.times) || (basinGridData && basinGridData.times);
            if (!times) return;

            // Update time badge, label, and panel timestamps
            const timeStr = new Date(times[timeIndex]).toLocaleString();
            document.getElementById('map-time-badge').textContent = timeStr;
            document.getElementById('time-label').textContent = 'Time: ' + timeStr;
            document.querySelectorAll('.panel-timestamp').forEach(el => el.textContent = timeStr);

            // === Update basin map ===
            if (basinGridData && mapBasin) {
                updateBasinMap(timeIndex);
            }

            // === Update local maps ===
            if (localGridData && map1 && map2 && map3) {
                const lLats = localGridData.lats;
                const lLons = localGridData.lons;
                const localRes = lLats.length > 1 ? Math.abs(lLats[1] - lLats[0]) : 0.25;
                const lHalfRes = localRes / 2;
                const lTimeIndex = Math.min(timeIndex, localGridData.times.length - 1);

                // Fast path: reuse existing rectangles/markers
                if (localRectsBuilt && localPeriodRects.length > 0) {
                    for (const entry of localPeriodRects) {
                        const period = localGridData.wave_period[lTimeIndex][entry.i][entry.j];
                        const color = getColorForValue(period, 0, 12);
                        entry.rect.setStyle({fillColor: color, color: color});
                        entry.rect.setPopupContent(`Wave Period: ${period.toFixed(1)} s`);
                    }
                    for (const entry of localHeightRects) {
                        const height = localGridData.wave_height[lTimeIndex][entry.i][entry.j];
                        const color = getColorForValue(height, 0, 3);
                        entry.rect.setStyle({fillColor: color, color: color});
                        entry.rect.setPopupContent(`Wave Height: ${(height * M_TO_FT).toFixed(1)} ft`);
                    }
                    for (const entry of localWindMarkers) {
                        const speed = localGridData.wind_speed[lTimeIndex][entry.i][entry.j];
                        const direction = localGridData.wind_direction[lTimeIndex][entry.i][entry.j];
                        const color = getWindColor(speed);
                        const rotation = (direction + 180) % 360;
                        if (entry.arrowDiv) {
                            entry.arrowDiv.style.transform = `rotate(${rotation}deg)`;
                            entry.arrowDiv.style.color = color;
                        }
                        entry.marker.setPopupContent(`Wind: ${(speed * KMH_TO_MPH).toFixed(1)} mph<br>Direction: ${direction.toFixed(0)}`);
                    }
                    return;
                }

                // Slow path: first render  destroy old layers, build new ones with batching
                if (localWavePeriodLayer) map1.removeLayer(localWavePeriodLayer);
                if (localWaveHeightLayer) map2.removeLayer(localWaveHeightLayer);
                if (localWindLayer) map3.removeLayer(localWindLayer);

                localWavePeriodLayer = L.layerGroup();
                localWaveHeightLayer = L.layerGroup();
                localWindLayer = L.layerGroup();

                const localPeriodRenderer = L.canvas({ padding: 0.5, oceanClip: true });
                const localHeightRenderer = L.canvas({ padding: 0.5, oceanClip: true });

                localPeriodRects = [];
                localHeightRects = [];
                localWindMarkers = [];

                const periodDescs = [];
                const heightDescs = [];
                const windDescs = [];

                for (let i = 0; i < lLats.length; i++) {
                    for (let j = 0; j < lLons.length; j++) {
                        const period = localGridData.wave_period[lTimeIndex][i][j];
                        const height = localGridData.wave_height[lTimeIndex][i][j];
                        const lat = lLats[i];
                        const lon = lLons[j];
                        const bounds = [[lat - lHalfRes, lon - lHalfRes], [lat + lHalfRes, lon + lHalfRes]];

                        if (period > 0) {
                            const color = getColorForValue(period, 0, 12);
                            periodDescs.push({
                                type: 'rect', bounds, i, j,
                                options: {renderer: localPeriodRenderer, color, weight: 0, fillColor: color, fillOpacity: 0.7},
                                popup: `Wave Period: ${period.toFixed(1)} s`,
                                store: localPeriodRects
                            });
                        }
                        if (height > 0) {
                            const color = getColorForValue(height, 0, 3);
                            heightDescs.push({
                                type: 'rect', bounds, i, j,
                                options: {renderer: localHeightRenderer, color, weight: 0, fillColor: color, fillOpacity: 0.7},
                                popup: `Wave Height: ${(height * M_TO_FT).toFixed(1)} ft`,
                                store: localHeightRects
                            });
                        }
                    }
                }

                // Wind arrows (every 5th point)
                const step = Math.max(1, Math.floor(lLats.length / 5));
                for (let i = 0; i < lLats.length; i += step) {
                    for (let j = 0; j < lLons.length; j += step) {
                        const speed = localGridData.wind_speed[lTimeIndex][i][j];
                        const direction = localGridData.wind_direction[lTimeIndex][i][j];

                        if (speed > 0) {
                            const color = getWindColor(speed);
                            const rotation = (direction + 180) % 360;
                            const arrowHtml = `<div style="transform: rotate(${rotation}deg); color: ${color}; font-size: 18px; text-shadow: 1px 1px 2px black;">&#10148;</div>`;
                            const arrowIcon = L.divIcon({
                                html: arrowHtml,
                                className: 'wind-arrow',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            });

                            windDescs.push({
                                type: 'marker', latlng: [lLats[i], lLons[j]], i, j,
                                icon: arrowIcon,
                                popup: `Wind: ${(speed * KMH_TO_MPH).toFixed(1)} mph<br>Direction: ${direction.toFixed(0)}`,
                                store: localWindMarkers, arrowDiv: null
                            });
                        }
                    }
                }

                batchGeneration++;
                const gen = batchGeneration;
                // Batch all three layer groups; mark built when last one finishes
                let layersDone = 0;
                const onLayerDone = () => {
                    layersDone++;
                    if (layersDone === 3) {
                        // Grab arrowDiv references from the DOM markers now that they're rendered
                        for (const entry of localWindMarkers) {
                            const el = entry.marker.getElement && entry.marker.getElement();
                            if (el) entry.arrowDiv = el.querySelector('div');
                        }
                        localRectsBuilt = true;
                    }
                };
                batchAddLayers(periodDescs, localWavePeriodLayer, map1, gen, onLayerDone);
                batchAddLayers(heightDescs, localWaveHeightLayer, map2, gen, onLayerDone);
                batchAddLayers(windDescs, localWindLayer, map3, gen, onLayerDone);
            }
        }

        // === IntersectionObserver for lazy map rendering ===
        const mapVisibility = {};
        const mapObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const id = entry.target.id;
                mapVisibility[id] = entry.isIntersecting;
                if (entry.isIntersecting) {
                    // Basin map
                    if (id === 'map-basin' && basinDataReady && !basinRendered) {
                        renderBasinMap();
                    }
                    // Local maps  any one becoming visible triggers all three
                    if ((id === 'map-wave-height' || id === 'map-wind' || id === 'map-wave-period') && localDataReady && !localRendered) {
                        renderLocalMaps();
                    }
                }
            });
        }, { threshold: 0.1 });

        // === Slider Animation Functions ===
        function advanceSlider() {
            const slider = document.getElementById('time-slider');
            let val = parseInt(slider.value);
            const max = parseInt(slider.max);
            if (max <= 0) return;
            val = val + SLIDER_ANIMATION_STEP;
            if (val > max) val = 0;
            slider.value = val;
            slider.dispatchEvent(new Event('input'));
        }

        function startSliderPlay() {
            if (sliderAnimationId) return;
            const btn = document.getElementById('slider-play-btn');
            btn.innerHTML = '&#10074;&#10074;';
            btn.title = 'Pause';
            btn.classList.add('playing');
            sliderAnimationId = setInterval(advanceSlider, sliderAnimationSpeed);
        }

        function stopSliderPlay() {
            if (!sliderAnimationId) return;
            clearInterval(sliderAnimationId);
            sliderAnimationId = null;
            const btn = document.getElementById('slider-play-btn');
            btn.innerHTML = '&#9654;';
            btn.title = 'Play';
            btn.classList.remove('playing');
        }

        function toggleSliderPlay() {
            if (sliderAnimationId) {
                stopSliderPlay();
            } else {
                startSliderPlay();
            }
        }

        function cycleSliderSpeed() {
            sliderSpeedIndex = (sliderSpeedIndex + 1) % SLIDER_SPEEDS.length;
            sliderAnimationSpeed = SLIDER_SPEEDS[sliderSpeedIndex];
            document.getElementById('slider-speed-btn').textContent = SLIDER_SPEED_LABELS[sliderSpeedIndex];
            if (sliderAnimationId) {
                clearInterval(sliderAnimationId);
                sliderAnimationId = setInterval(advanceSlider, sliderAnimationSpeed);
            }
        }

        // Start observing map containers once DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            ['map-basin', 'map-wave-height', 'map-wind', 'map-wave-period'].forEach(id => {
                const el = document.getElementById(id);
                if (el) mapObserver.observe(el);
            });

            // Wire up the slider with requestAnimationFrame debounce
            document.getElementById('time-slider').addEventListener('input', function(e) {
                const timeIndex = parseInt(e.target.value);
                // Update label immediately (cheap DOM write)
                const times = (localGridData && localGridData.times) || (basinGridData && basinGridData.times);
                if (times && times[timeIndex]) {
                    const timeStr = new Date(times[timeIndex]).toLocaleString();
                    document.getElementById('map-time-badge').textContent = timeStr;
                    document.getElementById('time-label').textContent = 'Time: ' + timeStr;
                    document.querySelectorAll('.panel-timestamp').forEach(el => el.textContent = timeStr);
                }
                // Debounce expensive map update to 1 per frame
                if (sliderRafId) cancelAnimationFrame(sliderRafId);
                sliderRafId = requestAnimationFrame(() => {
                    updateAllMaps(timeIndex);
                    sliderRafId = null;
                });
            });

            // Wire up play/pause and speed buttons
            document.getElementById('slider-play-btn').addEventListener('click', toggleSliderPlay);
            document.getElementById('slider-speed-btn').addEventListener('click', cycleSliderSpeed);
        });

        // Local maps loaded via staggered init in loadPointForecast listener

        // Tide chart script
        let tideChart = null;

        function loadTideData() {
            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            fetch(`/api/tides?${params}`)
                .then(response => response.json())
                .then(tideData => {
                    if (tideData.error) {
                        console.error('API Error (Tide Data):', tideData.error);
                        showChartUnavailable('tideChart', 'Tide data unavailable');
                        document.getElementById('tide-station-info').textContent = 'Unavailable';
                        return;
                    }
                    clearChartUnavailable('tideChart');

                    const ctx = document.getElementById('tideChart').getContext('2d');

                    // Update station info display
                    if (tideData.station) {
                        const stationInfo = document.getElementById('tide-station-info');
                        stationInfo.textContent = `${tideData.station.name}  ${(tideData.station.distance_km * KM_TO_MI).toFixed(1)} mi`;
                    }

                    // Prepare hourly data as {x, y} points
                    const tideTimes = tideData.hourly.map(item => new Date(item.time));
                    tideTimeRange = { min: tideTimes[0], max: tideTimes[tideTimes.length - 1] };

                    const heightsData = tideData.hourly.map(item => ({
                        x: new Date(item.time), y: item.height * M_TO_FT
                    }));

                    // Prepare high/low annotations
                    const highLowPoints = tideData.high_low.map(item => {
                        const d = new Date(item.time);
                        return {
                            time: d,
                            height: item.height,
                            type: item.type,
                            label: item.type === 'H' ? 'High' : 'Low'
                        };
                    });

                    const highTides = [];
                    const lowTides = [];

                    tideData.hourly.forEach((item, index) => {
                        const itemTime = new Date(item.time).getTime();

                        const matchingHighLow = highLowPoints.find(hl =>
                            Math.abs(hl.time.getTime() - itemTime) < 30 * 60 * 1000
                        );

                        if (matchingHighLow) {
                            if (matchingHighLow.type === 'H') {
                                highTides.push({ x: new Date(item.time), y: item.height * M_TO_FT });
                                lowTides.push(null);
                            } else {
                                lowTides.push({ x: new Date(item.time), y: item.height * M_TO_FT });
                                highTides.push(null);
                            }
                        } else {
                            highTides.push(null);
                            lowTides.push(null);
                        }
                    });

                    // Destroy existing chart if it exists
                    if (tideChart) {
                        tideChart.destroy();
                    }

                    tideChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'Tide Height (ft)',
                                    data: heightsData,
                                    borderColor: 'rgb(54, 162, 235)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: true,
                                    tension: 0.4,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'High Tide',
                                    data: highTides,
                                    borderColor: 'transparent',
                                    backgroundColor: 'rgb(255, 99, 132)',
                                    pointRadius: 8,
                                    pointStyle: 'triangle',
                                    showLine: false
                                },
                                {
                                    label: 'Low Tide',
                                    data: lowTides,
                                    borderColor: 'transparent',
                                    backgroundColor: 'rgb(75, 192, 192)',
                                    pointRadius: 8,
                                    pointStyle: 'rectRot',
                                    showLine: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            hour: 'MMM d HH:mm'
                                        },
                                        tooltipFormat: 'MMM d, yyyy HH:mm'
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 45,
                                        autoSkip: true,
                                        maxTicksLimit: 24,
                                        color: '#888'
                                    },
                                    grid: {
                                        color: 'rgba(42, 42, 42, 0.8)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Height above MLLW (ft)',
                                        color: 'rgb(54, 162, 235)'
                                    },
                                    ticks: {
                                        color: 'rgb(54, 162, 235)'
                                    },
                                    grid: {
                                        color: 'rgba(54, 162, 235, 0.15)'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    position: 'right',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Wind Speed (mph)',
                                        color: 'transparent'
                                    },
                                    ticks: {
                                        color: 'transparent'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    labels: { color: '#888' }
                                },
                                tooltip: {
                                    callbacks: {
                                        afterBody: function(context) {
                                            const index = context[0].dataIndex;
                                            if (highTides[index] !== null) return ' High Tide';
                                            if (lowTides[index] !== null) return ' Low Tide';
                                            return '';
                                        }
                                    }
                                },
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x'
                                    },
                                    zoom: {
                                        wheel: { enabled: true },
                                        pinch: { enabled: true },
                                        mode: 'x',
                                        onZoomComplete: () => document.getElementById('tide-chart-reset').style.display = ''
                                    }
                                }
                            }
                        }
                    });

                    syncChartTimeAxes();
                })
                .catch(error => {
                    console.error('Error fetching tide data:', error);
                    showChartUnavailable('tideChart', 'Tide data unavailable');
                    document.getElementById('tide-station-info').textContent = 'Unavailable';
                });
        }

        // Tide data loaded via staggered init in loadPointForecast listener

        // === Surf Cams (Dynamic) ===
        var activeCamInstances = {};

        function destroyCam(slotIndex) {
            if (activeCamInstances[slotIndex]) {
                try { activeCamInstances[slotIndex].destroy(); } catch (e) {}
                delete activeCamInstances[slotIndex];
            }
        }

        function setCamPanel(slotIndex, camData) {
            var panelId = 'cam-' + (slotIndex + 1);
            var titleEl = document.getElementById(panelId + '-title');
            var badgeEl = document.getElementById(panelId + '-badge');
            var contentEl = document.getElementById(panelId + '-content');
            if (!contentEl) return;

            destroyCam(slotIndex);
            contentEl.innerHTML = '';

            if (!camData) {
                // No camera  hide panel (unless user manually controls it)
                titleEl.textContent = 'Live Cam';
                badgeEl.textContent = 'Off';
                badgeEl.style.color = '';
                contentEl.innerHTML = '<div style="padding: 16px; color: var(--text-muted); font-size: 11px;">No nearby camera found</div>';
                PANEL_NAMES[panelId] = 'Live Cam ' + (slotIndex + 1);
                togglePanel(panelId, false);
                return;
            }

            var distMi = Math.round(camData.distance_km * 0.621371);
            var label = camData.name + ' \u2014 ' + distMi + ' mi';
            titleEl.textContent = label;
            PANEL_NAMES[panelId] = camData.name + ' \u2014 Live Cam';

            if (camData.type === 'hls') {
                var video = document.createElement('video');
                video.style.cssText = 'width:100%;display:block;background:#000;';
                video.muted = true;
                video.autoplay = true;
                video.playsInline = true;
                contentEl.appendChild(video);

                if (Hls.isSupported()) {
                    var hls = new Hls();
                    activeCamInstances[slotIndex] = hls;
                    hls.loadSource(camData.url);
                    hls.attachMedia(video);
                    hls.on(Hls.Events.ERROR, function(event, data) {
                        if (data.fatal) {
                            video.style.display = 'none';
                            badgeEl.textContent = 'Error';
                            badgeEl.style.color = 'var(--status-error)';
                            contentEl.innerHTML = '<div style="padding: 8px; font-size: 11px; color: var(--status-error);">Stream unavailable</div>';
                        }
                    });
                    badgeEl.textContent = 'Live';
                    badgeEl.style.color = '';
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = camData.url;
                    badgeEl.textContent = 'Live';
                    badgeEl.style.color = '';
                } else {
                    contentEl.innerHTML = '<div style="padding: 8px; font-size: 11px; color: var(--status-error);">Stream unavailable</div>';
                    badgeEl.textContent = 'Error';
                    badgeEl.style.color = 'var(--status-error)';
                }
            } else if (camData.type === 'iframe') {
                var iframe = document.createElement('iframe');
                iframe.src = camData.url;
                iframe.style.cssText = 'width:100%;height:100%;border:none;background:#000;';
                iframe.allow = 'autoplay';
                contentEl.appendChild(iframe);
                badgeEl.textContent = 'Live';
                badgeEl.style.color = '';
            }

            // Re-show panel unless user has manually hidden it
            if (!getHiddenPanels().includes(panelId)) {
                togglePanel(panelId, true);
            }
        }

        // === Buoy Observations ===
        let spectrumChart = null;
        let buoyData = null;

        function showBuoyLoading() {
            var panel = document.getElementById('buoy-panel-content');
            var overlay = document.getElementById('buoy-loading-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'buoy-loading-overlay';
                overlay.className = 'buoy-loading-overlay';
                overlay.textContent = 'Loading buoy data...';
                panel.style.position = 'relative';
                panel.appendChild(overlay);
            }
            overlay.style.display = '';
        }

        function hideBuoyLoading() {
            var overlay = document.getElementById('buoy-loading-overlay');
            if (overlay) overlay.style.display = 'none';
        }

        function loadBuoyData() {
            var params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });
            var badge = document.getElementById('buoy-badge');
            var error = document.getElementById('buoy-error');
            var layout = document.querySelector('.buoy-panel-layout');
            badge.textContent = 'Loading';
            error.style.display = 'none';
            layout.style.display = '';
            showBuoyLoading();

            // Destroy old map so it gets recreated for the new location
            if (buoyMap) {
                buoyMap.remove();
                buoyMap = null;
                buoyMapMarker = null;
                buoyMapLocMarker = null;
            }

            fetch('/api/buoys?' + params)
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    hideBuoyLoading();
                    if (data.error || !data.buoys || data.buoys.length === 0) {
                        layout.style.display = 'none';
                        error.textContent = 'No buoys found nearby';
                        error.style.display = '';
                        badge.textContent = 'Off';
                        return;
                    }
                    buoyData = data;
                    badge.textContent = 'Live';

                    // Populate selector
                    var sel = document.getElementById('buoy-selector');
                    sel.innerHTML = '';
                    data.buoys.forEach(function(b, i) {
                        var opt = document.createElement('option');
                        var distMi = Math.round(b.distance_km * 0.621371);
                        opt.value = i;
                        opt.textContent = b.source.toUpperCase() + ' ' + b.id + '  ' + distMi + ' mi';
                        sel.appendChild(opt);
                    });
                    sel.onchange = function() { selectBuoy(data.buoys[parseInt(sel.value)]); };

                    selectBuoy(data.buoys[0]);
                })
                .catch(function(err) {
                    console.error('Buoy fetch error:', err);
                    hideBuoyLoading();
                    layout.style.display = 'none';
                    error.textContent = 'Buoy data unavailable';
                    error.style.display = '';
                    badge.textContent = 'Error';
                });
        }

        let buoyMap = null;
        let buoyMapMarker = null;
        let buoyMapLocMarker = null;

        function updateBuoyMap(buoy) {
            var container = document.getElementById('buoy-map');
            if (!container || container.clientHeight < 10 || container.clientWidth < 10) return;
            if (!buoyMap) {
                buoyMap = L.map(container, {
                    zoomControl: false,
                    attributionControl: false,
                    dragging: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    keyboard: false,
                    touchZoom: false
                }).setView([buoy.lat, buoy.lon], 9);
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
                    maxZoom: 14
                }).addTo(buoyMap);
            }

            if (buoyMapMarker) buoyMap.removeLayer(buoyMapMarker);
            if (buoyMapLocMarker) buoyMap.removeLayer(buoyMapLocMarker);

            // User location marker (yellow star, matches ocean basin map)
            var starIcon = L.divIcon({
                html: '<div style="color:#ff0;font-size:16px;text-shadow:1px 1px 3px #000;">&#9733;</div>',
                className: 'location-marker',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            buoyMapLocMarker = L.marker([currentLocation.lat, currentLocation.lon], {icon: starIcon}).addTo(buoyMap);

            // Buoy marker
            buoyMapMarker = L.circleMarker([buoy.lat, buoy.lon], {
                radius: 6, fillColor: '#44ff88', fillOpacity: 0.9, color: '#fff', weight: 1.5
            }).addTo(buoyMap);

            // Fit both points in view
            var bounds = L.latLngBounds(
                [buoy.lat, buoy.lon],
                [currentLocation.lat, currentLocation.lon]
            ).pad(0.3);
            buoyMap.fitBounds(bounds, { maxZoom: 11 });
        }

        function selectBuoy(buoy) {
            renderBuoyStats(buoy);
            updateBuoyMap(buoy);
            // Retry map/charts after layout settles (helps on mobile initial load)
            setTimeout(function() {
                updateBuoyMap(buoy);
                if (buoy.spectrum) {
                    render1DSpectrum(buoy.spectrum);
                    if (buoy.directional) {
                        var pc = document.getElementById('polarCanvas');
                        if (pc && pc.parentElement.clientWidth > 20) render2DSpectrum(buoy.directional, buoy.spectrum);
                    }
                }
            }, 300);

            var wrap1d = document.getElementById('spectrum-1d-wrap');
            var wrap2d = document.getElementById('spectrum-2d-wrap');
            var noSpecMsg = document.getElementById('spectrum-unavailable');
            if (!noSpecMsg) {
                noSpecMsg = document.createElement('div');
                noSpecMsg.id = 'spectrum-unavailable';
                noSpecMsg.className = 'chart-unavailable';
                noSpecMsg.textContent = 'No spectral data available';
                document.querySelector('.buoy-spectrum').appendChild(noSpecMsg);
            }
            var noDirMsg = document.getElementById('directional-unavailable');

            if (buoy.spectrum) {
                noSpecMsg.style.display = 'none';
                wrap1d.style.display = '';
                wrap2d.style.display = '';
                render1DSpectrum(buoy.spectrum);

                if (buoy.directional) {
                    noDirMsg.style.display = 'none';
                    document.getElementById('polarCanvas').style.display = '';
                    render2DSpectrum(buoy.directional, buoy.spectrum);
                } else {
                    document.getElementById('polarCanvas').style.display = 'none';
                    noDirMsg.style.display = '';
                }
            } else {
                wrap1d.style.display = 'none';
                wrap2d.style.display = 'none';
                noSpecMsg.style.display = '';
            }
        }

        function renderBuoyStats(buoy) {
            var ts = document.getElementById('buoy-timestamp');
            ts.textContent = buoy.time || '';

            function fmt(v, unit, conv) {
                if (v == null) return '-';
                if (conv) v = conv(v);
                return (typeof v === 'number' ? v.toFixed(1) : v) + ' ' + unit;
            }

            var dirArrow = '';
            if (buoy.wave_direction != null) {
                dirArrow = ' ' + degToArrow(buoy.wave_direction);
            }
            document.getElementById('buoy_wave_height').textContent = fmt(buoy.wave_height, 'ft', function(v) { return v * M_TO_FT; });
            document.getElementById('buoy_wave_period').textContent = fmt(buoy.dominant_period, 's');
            document.getElementById('buoy_wave_dir').innerHTML = buoy.wave_direction != null ? Math.round(buoy.wave_direction) + '&deg;' + dirArrow : '-';

            if (buoy.wind_speed != null) {
                var windMph = (buoy.wind_speed * 2.23694).toFixed(0);
                var windDir = buoy.wind_direction != null ? degToCompass(buoy.wind_direction) + ' ' : '';
                document.getElementById('buoy_wind').textContent = windDir + windMph + ' mph';
                if (buoy.wind_gust != null) {
                    document.getElementById('buoy_wind').textContent += ' (G' + (buoy.wind_gust * 2.23694).toFixed(0) + ')';
                }
            } else {
                document.getElementById('buoy_wind').textContent = '-';
            }

            document.getElementById('buoy_water_temp').textContent = fmt(buoy.water_temp, '\u00B0F', function(v) { return v * 9/5 + 32; });
            document.getElementById('buoy_air_temp').textContent = fmt(buoy.air_temp, '\u00B0F', function(v) { return v * 9/5 + 32; });
            document.getElementById('buoy_pressure').textContent = fmt(buoy.pressure, 'mb');
        }

        function degToCompass(deg) {
            var dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
            return dirs[Math.round(deg / 22.5) % 16];
        }

        function degToArrow(deg) {
            // Arrow points in direction wave is coming FROM (meteorological convention)
            var arrows = ['\u2193','\u2199','\u2190','\u2196','\u2191','\u2197','\u2192','\u2198'];
            return arrows[Math.round(deg / 45) % 8];
        }

        function render1DSpectrum(spectrum) {
            var ctx = document.getElementById('spectrumChart');
            // Convert frequencies to periods and reverse for longshort display
            var points = [];
            for (var i = 0; i < spectrum.frequencies.length; i++) {
                var f = spectrum.frequencies[i];
                var period = 1 / f;
                if (period >= 2 && period <= 30) {
                    points.push({ period: period, energy: spectrum.energy[i] });
                }
            }
            points.sort(function(a, b) { return b.period - a.period; });

            var labels = points.map(function(p) { return p.period.toFixed(1); });
            var data = points.map(function(p) { return p.energy; });

            if (spectrumChart) spectrumChart.destroy();
            spectrumChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Energy Density (m\u00B2/Hz)',
                        data: data,
                        borderColor: '#3388ff',
                        backgroundColor: 'rgba(51, 136, 255, 0.15)',
                        fill: true,
                        pointRadius: 0,
                        borderWidth: 1.5,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(items) { return items[0].label + 's period'; },
                                label: function(item) { return item.raw.toFixed(3) + ' m\u00B2/Hz'; }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Period (s)', color: '#888', font: { size: 10, family: 'inherit' } },
                            ticks: { color: '#666', font: { size: 9 }, maxTicksLimit: 12 },
                            grid: { color: 'rgba(255,255,255,0.05)' }
                        },
                        y: {
                            title: { display: true, text: 'Energy (m\u00B2/Hz)', color: '#888', font: { size: 10, family: 'inherit' } },
                            ticks: { color: '#666', font: { size: 9 } },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function spectrumColor(frac) {
            // Color scale: dark blue  cyan  yellow  red
            var r, g, b;
            if (frac < 0.25) {
                var t = frac / 0.25;
                r = 0; g = Math.round(80 * t); b = Math.round(120 + 135 * t);
            } else if (frac < 0.5) {
                var t = (frac - 0.25) / 0.25;
                r = 0; g = Math.round(80 + 175 * t); b = Math.round(255 * (1 - t));
            } else if (frac < 0.75) {
                var t = (frac - 0.5) / 0.25;
                r = Math.round(255 * t); g = 255; b = 0;
            } else {
                var t = (frac - 0.75) / 0.25;
                r = 255; g = Math.round(255 * (1 - t)); b = 0;
            }
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        function render2DSpectrum(directional, spectrum) {
            var canvas = document.getElementById('polarCanvas');
            var w = canvas.parentElement.clientWidth;
            var h = canvas.parentElement.clientHeight;
            if (w < 20 || h < 20) return;
            var ctx = canvas.getContext('2d');
            canvas.width = w * (window.devicePixelRatio || 1);
            canvas.height = h * (window.devicePixelRatio || 1);
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);

            var cx = w / 2;
            var cy = h / 2;
            var maxR = Math.min(cx, cy) - 10;
            if (maxR < 15) return;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);

            // Period rings
            var ringPeriods = [5, 10, 15, 20];
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 0.5;
            ctx.fillStyle = '#666';
            ctx.font = '8px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ringPeriods.forEach(function(p) {
                var r = (p / 25) * maxR;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillText(p + 's', cx + 2, cy - r - 1);
            });

            // Cardinal directions  placed just inside the outer ring edge
            var cardinals = [['N', 0], ['E', 90], ['S', 180], ['W', 270]];
            ctx.fillStyle = '#999';
            ctx.font = 'bold 9px monospace';
            cardinals.forEach(function(cd) {
                var angle = (cd[1] - 90) * Math.PI / 180;
                var x = cx + (maxR - 6) * Math.cos(angle);
                var y = cy + (maxR - 6) * Math.sin(angle);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(cd[0], x, y);
            });

            // Build directional energy grid
            var freqs = spectrum.frequencies;
            var energy = spectrum.energy;
            var nDir = 72; // 5-degree bins
            var maxEnergy = 0;
            var grid = [];

            for (var fi = 0; fi < freqs.length; fi++) {
                var row = [];
                for (var di = 0; di < nDir; di++) {
                    var theta = di * 5 * Math.PI / 180;
                    var E = energy[fi];
                    var val;
                    if (directional.a1 && directional.a1.length > fi) {
                        // CDIP Fourier: D(theta,f) = E(f) * [1 + 2*a1*cos(theta) + 2*b1*sin(theta) + 2*a2*cos(2*theta) + 2*b2*sin(2*theta)] / (2*pi)
                        var a1 = directional.a1[fi] || 0;
                        var b1 = directional.b1[fi] || 0;
                        var a2 = directional.a2[fi] || 0;
                        var b2 = directional.b2[fi] || 0;
                        val = E * (1 + 2*a1*Math.cos(theta) + 2*b1*Math.sin(theta) + 2*a2*Math.cos(2*theta) + 2*b2*Math.sin(2*theta)) / (2 * Math.PI);
                    } else if (directional.directions && directional.r1 && directional.directions.length > fi) {
                        // NDBC: mean direction + r1 spread
                        var meanDir = directional.directions[fi] * Math.PI / 180;
                        var r1 = directional.r1[fi] || 0.5;
                        var diff = theta - meanDir;
                        val = E * (1 + 2 * r1 * Math.cos(diff)) / (2 * Math.PI);
                    } else {
                        val = E / (2 * Math.PI);
                    }
                    val = Math.max(0, val);
                    if (val > maxEnergy) maxEnergy = val;
                    row.push(val);
                }
                grid.push(row);
            }

            if (maxEnergy === 0) return;

            // Draw polar heatmap
            for (var fi = 0; fi < freqs.length - 1; fi++) {
                var period = 1 / freqs[fi];
                var periodNext = 1 / freqs[fi + 1];
                if (period > 25 || period < 1) continue;
                var r1 = (period / 25) * maxR;
                var r2 = (periodNext / 25) * maxR;
                var rInner = Math.min(r1, r2);
                var rOuter = Math.max(r1, r2);

                for (var di = 0; di < nDir; di++) {
                    var val = grid[fi][di];
                    if (val < maxEnergy * 0.01) continue;
                    var frac = Math.min(1, val / maxEnergy);

                    var angle1 = (di * 5 - 90) * Math.PI / 180;
                    var angle2 = ((di + 1) * 5 - 90) * Math.PI / 180;

                    ctx.fillStyle = spectrumColor(frac);
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(cx, cy, rOuter, angle1, angle2);
                    ctx.arc(cx, cy, rInner, angle2, angle1, true);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw legend in bottom-right (matches map legend style)
            var compact = (w < 200 || h < 160);
            var legendPad = compact ? 4 : 6;
            var swatchW = compact ? 12 : 16;
            var swatchH = compact ? 8 : 10;
            var nSwatches = compact ? 4 : 5;
            var legendFont = (compact ? '8' : '9') + 'px monospace';
            var titleFont = 'bold ' + (compact ? '8' : '9') + 'px monospace';
            ctx.font = legendFont;
            // Build labels
            var legendLabels = [];
            for (var i = 0; i < nSwatches; i++) {
                var val = maxEnergy * i / (nSwatches - 1);
                legendLabels.push(val < 0.01 ? '0' : val.toFixed(2));
            }
            var maxLabelW = 0;
            legendLabels.forEach(function(lbl) {
                var lw = ctx.measureText(lbl).width;
                if (lw > maxLabelW) maxLabelW = lw;
            });
            ctx.font = titleFont;
            var titleText = compact ? 'm\u00B2/Hz/\u00B0' : 'Energy (m\u00B2/Hz/\u00B0)';
            var titleW = ctx.measureText(titleText).width;
            var lineH = compact ? 12 : 14;
            var titleH = lineH + 2;
            var contentW = Math.max(titleW, swatchW + 4 + maxLabelW);
            var boxW = legendPad * 2 + contentW;
            var boxH = legendPad + titleH + nSwatches * lineH + legendPad - 4;
            var boxX = w - boxW - 4;
            var boxY = h - boxH - 4;

            // Background
            ctx.fillStyle = 'rgba(20, 20, 20, 0.92)';
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = 'rgba(42, 42, 42, 1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(boxX, boxY, boxW, boxH);

            // Title
            ctx.fillStyle = '#e8e8e8';
            ctx.font = titleFont;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(titleText, boxX + legendPad, boxY + legendPad);

            // Swatches high  low
            for (var i = nSwatches - 1; i >= 0; i--) {
                var row = nSwatches - 1 - i;
                var sy = boxY + legendPad + titleH + row * lineH;
                ctx.fillStyle = spectrumColor(i / (nSwatches - 1));
                ctx.fillRect(boxX + legendPad, sy, swatchW, swatchH);
                ctx.fillStyle = '#888';
                ctx.font = legendFont;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(legendLabels[i], boxX + legendPad + swatchW + 4, sy + swatchH / 2);
            }
        }


        function loadNearestCams() {
            var params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });
            // Show loading state
            for (var i = 0; i < 2; i++) {
                var cEl = document.getElementById('cam-' + (i + 1) + '-content');
                var bEl = document.getElementById('cam-' + (i + 1) + '-badge');
                if (cEl) cEl.innerHTML = '<div style="padding: 16px; color: var(--text-muted); font-size: 11px;">Finding nearest camera...</div>';
                if (bEl) { bEl.textContent = 'Loading'; bEl.style.color = ''; }
            }
            fetch('/api/webcams?' + params)
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    var cameras = data.cameras || [];
                    setCamPanel(0, cameras[0] || null);
                    setCamPanel(1, cameras[1] || null);
                })
                .catch(function() {
                    setCamPanel(0, null);
                    setCamPanel(1, null);
                });
        }

        document.addEventListener('DOMContentLoaded', function() {
            loadNearestCams();
        });
    </script>
</body>
</html>
