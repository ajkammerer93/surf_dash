<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Surf Forecast</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><path d='M2 20 Q8 10 14 18 Q20 26 26 16 Q29 11 30 12' fill='none' stroke='%2344ff88' stroke-width='3' stroke-linecap='round'/><path d='M2 24 Q8 16 14 22 Q20 28 26 20 Q29 16 30 17' fill='none' stroke='%233388ff' stroke-width='2.5' stroke-linecap='round'/></svg>">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <!-- Leaflet Velocity CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-velocity@2.1.4/dist/leaflet-velocity.css" />
    <!-- GridStack CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@10/dist/gridstack.min.css" />
    <style>
        /* === Design Tokens === */
        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --border: #2a2a2a;
            --text: #e8e8e8;
            --text-dim: #888;
            --text-muted: #666;
            --accent: #fff;
            --status-live: #44ff88;
            --status-warning: #ffaa00;
            --status-error: #ff4444;
            --font-body: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Consolas', monospace;
        }

        /* === Reset & Base === */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-body);
            font-size: 12px;
            line-height: 1.4;
            -webkit-font-smoothing: antialiased;
        }

        /* === Scrollbar === */
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        /* === Header === */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            z-index: 1000;
            gap: 12px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--accent);
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background 0.15s;
            min-width: 0;
            overflow: hidden;
        }

        .header-center:hover { background: rgba(255,255,255,0.05); }

        .header-location {
            font-size: 11px;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .header-coords {
            font-size: 10px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .header-clock {
            font-size: 11px;
            color: var(--text-dim);
            font-variant-numeric: tabular-nums;
        }

        .header-version {
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border: 1px solid var(--border);
            border-radius: 2px;
        }

        .header-btn {
            font-family: var(--font-body);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 10px;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .header-btn:hover {
            color: var(--text);
            border-color: var(--text-muted);
            background: rgba(255,255,255,0.03);
        }

        /* === GridStack Dashboard === */
        .grid-stack {
            margin-top: 40px;
        }

        .grid-stack-item-content {
            background: var(--surface);
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .grid-stack-item-content .panel {
            display: flex;
            flex-direction: column;
            min-width: 0;
            height: 100%;
            overflow: hidden;
        }

        /* Keep dragging widgets below the header */
        .grid-stack-item.ui-draggable-dragging {
            z-index: 900 !important;
        }

        /* Placeholder styling for dark theme */
        .grid-stack-placeholder > .placeholder-content {
            background: rgba(255, 255, 255, 0.03) !important;
            border: 1px dashed var(--text-muted) !important;
        }

        /* Resize handle styling */
        .grid-stack-item > .ui-resizable-se {
            filter: invert(1) brightness(0.5);
        }

        /* Fullscreen wrapper on grid-stack-item */
        .grid-stack-item.panel-fullscreen-wrapper {
            position: fixed !important;
            inset: 0 !important;
            z-index: 1500 !important;
            width: 100% !important;
            height: 100% !important;
        }

        .grid-stack-item.panel-fullscreen-wrapper .panel-content {
            flex: 1;
            overflow: auto;
        }

        .grid-stack-item.panel-fullscreen-wrapper .map-container {
            height: 100% !important;
        }

        .grid-stack-item.panel-fullscreen-wrapper .chart-wrap {
            height: calc(100vh - 40px);
        }

        .grid-stack-item.panel-fullscreen-wrapper .panel-content {
            max-height: none !important;
        }

        .panel-header {
            padding: 6px 10px;
            background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            cursor: grab;
            position: relative;
            z-index: 1000;
        }

        .panel-header:active {
            cursor: grabbing;
        }

        .panel-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
        }

        .panel-badge {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border-radius: 2px;
            background: rgba(68, 255, 136, 0.1);
            color: var(--status-live);
            border: 1px solid rgba(68, 255, 136, 0.2);
        }

        .panel-header-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .panel-btn {
            font-family: var(--font-body);
            font-size: 12px;
            background: transparent;
            color: var(--text-muted);
            border: none;
            cursor: pointer;
            padding: 0 2px;
            line-height: 1;
            transition: color 0.15s;
        }

        .panel-btn:hover {
            color: var(--text);
        }


        /* Share button tooltip */
        .share-btn {
            font-family: var(--font-body);
            font-size: 12px;
            background: transparent;
            color: var(--text-muted);
            border: none;
            cursor: pointer;
            padding: 2px 4px;
            line-height: 1;
            transition: color 0.15s;
            position: relative;
        }

        .share-btn:hover { color: var(--text); }

        .share-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 14px;
            font-size: 11px;
            font-family: var(--font-body);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .share-toast.show {
            opacity: 1;
        }

        .panel-badge.warning {
            background: rgba(255, 170, 0, 0.1);
            color: var(--status-warning);
            border-color: rgba(255, 170, 0, 0.2);
        }

        .panel-badge.error {
            background: rgba(255, 68, 68, 0.1);
            color: var(--status-error);
            border-color: rgba(255, 68, 68, 0.2);
        }

        .panel-content {
            padding: 8px;
            flex: 1;
            overflow: auto;
        }

        /* === Map Containers === */
        .map-container {
            height: 100%;
            min-height: 200px;
            width: 100%;
        }

        .map-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 200px;
            color: var(--text-muted);
            font-size: 11px;
        }

        .map-data-error {
            font-family: var(--font-body);
            font-size: 10px;
            background: rgba(20, 20, 20, 0.85);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border);
            color: var(--status-warning);
            pointer-events: none;
            white-space: nowrap;
        }

        .chart-unavailable {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--status-warning);
            font-size: 11px;
            letter-spacing: 0.5px;
        }

        /* === Leaflet Legend === */
        .legend {
            font-family: var(--font-body);
            font-size: 10px;
            background: rgba(20, 20, 20, 0.92);
            padding: 6px 8px;
            border: 1px solid var(--border);
            line-height: 1.5;
            color: var(--text-dim);
        }

        .legend strong {
            color: var(--text);
            font-size: 10px;
        }

        .legend-color {
            display: inline-block;
            width: 16px;
            height: 10px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .wind-arrow {
            font-size: 14px;
            font-weight: bold;
        }

        /* === Basin Layer Dropdown === */
        .basin-layer-menu {
            position: relative;
            display: inline-block;
        }

        .basin-layer-btn {
            font-family: var(--font-body);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 8px;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .basin-layer-btn:hover {
            color: var(--text);
            border-color: var(--text-muted);
            background: rgba(255,255,255,0.03);
        }

        .basin-layer-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 4px);
            right: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 4px 0;
            z-index: 1100;
            min-width: 160px;
        }

        .basin-layer-dropdown.open {
            display: block;
        }

        .basin-layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            color: var(--text-dim);
            transition: background 0.1s;
            white-space: nowrap;
            user-select: none;
        }

        .basin-layer-item:hover {
            background: rgba(255,255,255,0.05);
            color: var(--text);
        }

        .basin-layer-item input[type="checkbox"] {
            accent-color: var(--status-live);
            cursor: pointer;
        }

        /* === Map Home Button === */
        .map-home-btn {
            width: 26px;
            height: 26px;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 14px;
            line-height: 26px;
            text-align: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .map-home-btn:hover {
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }

        .chart-home-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 10px;
            padding: 2px 8px;
            cursor: pointer;
            border-radius: 3px;
            display: none;
        }

        .chart-home-btn:hover {
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }

        /* === Time Slider === */
        .slider-row {
            padding: 6px 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-label {
            font-size: 10px;
            color: var(--text-muted);
            white-space: nowrap;
            min-width: 0;
            flex-shrink: 0;
        }

        .slider-input {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 3px;
            background: var(--border);
            outline: none;
            border-radius: 2px;
        }

        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--text-dim);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-input::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--text-dim);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* === Current Conditions (stat list) === */
        .stat-list {
            list-style: none;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            border-bottom: 1px solid var(--border);
        }

        .stat-item:last-child { border-bottom: none; }

        .stat-label {
            font-size: 11px;
            color: var(--text-dim);
        }

        .stat-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent);
            font-variant-numeric: tabular-nums;
        }

        /* === Offshore indicator === */
        .conditions-hint {
            font-size: 10px;
            color: var(--text-muted);
            padding: 4px 4px 0;
        }

        .conditions-hint .good { color: var(--status-live); }

        /* === Data Table === */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .data-table thead {
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .data-table th {
            padding: 6px 6px;
            text-align: left;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .data-table td {
            padding: 5px 6px;
            color: var(--text-dim);
            border-bottom: 1px solid rgba(42, 42, 42, 0.5);
            font-variant-numeric: tabular-nums;
        }

        .data-table tr.row-good td {
            color: var(--status-live);
        }

        /* === Charts === */
        .chart-wrap {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* === Modal (custom, no Bootstrap) === */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal-card {
            background: var(--surface);
            border: 1px solid var(--border);
            width: 100%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .modal-top {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text);
        }

        .modal-close {
            font-family: var(--font-body);
            font-size: 16px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text); }

        .modal-body {
            padding: 12px 14px;
            flex: 1;
            overflow: auto;
        }

        .modal-body p {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .modal-selected {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 10px;
        }

        .modal-selected strong {
            color: var(--text);
        }

        .modal-footer {
            padding: 10px 14px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .btn-modal {
            font-family: var(--font-body);
            font-size: 11px;
            padding: 6px 14px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-modal:hover {
            color: var(--text);
            border-color: var(--text-muted);
        }

        .btn-modal.primary {
            background: rgba(255,255,255,0.05);
            color: var(--text);
            border-color: var(--text-muted);
        }

        .btn-modal.primary:hover {
            background: rgba(255,255,255,0.1);
        }

        .btn-modal:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* === Responsive === */
        @media (max-width: 700px) {
            .header-center { display: none; }
        }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <a href="https://freesurfforecast.com/" class="header-title" style="text-decoration:none;color:inherit;">Free Surf Forecast</a>
            <button class="share-btn" onclick="copyShareLink()" title="Copy link">&#x1F517;</button>
            <a href="https://www.instagram.com/freesurfforecast/" target="_blank" rel="noopener" class="share-btn" title="Instagram" style="text-decoration:none;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><circle cx="12" cy="12" r="5"/><circle cx="17.5" cy="6.5" r="1.5"/></svg></a>
            <a href="https://github.com/ajkammerer93/surf_dash" target="_blank" rel="noopener" class="share-btn" title="GitHub" style="text-decoration:none;"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg></a>
            <span class="header-version">{{ version }}</span>
        </div>
        <div class="header-center" onclick="openModal()">
            <span class="header-location" id="location-name">Surf City, North Carolina</span>
            <span class="header-coords">
                <span id="display-lat">34.43</span>, <span id="display-lon">-77.54</span>
            </span>
        </div>
        <div class="header-right">
            <span class="header-clock" id="header-clock"></span>
            <button class="header-btn" onclick="openModal()">Change Location</button>
            <button class="header-btn" id="page-fullscreen-btn" onclick="togglePageFullscreen()" title="Fullscreen">&#x26F6;</button>
        </div>
    </div>

    <div class="share-toast" id="share-toast">Link copied to clipboard</div>

    <!-- Location Modal -->
    <div class="modal-overlay" id="locationModal">
        <div class="modal-card">
            <div class="modal-top">
                <span class="modal-title">Select Location</span>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>Click anywhere on the ocean to select a new forecast location.</p>
                <div id="location-map" style="height: 450px;"></div>
                <div class="modal-selected">
                    <strong>Selected:</strong> <span id="selected-location-text">None</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-modal" onclick="closeModal()">Cancel</button>
                <button class="btn-modal primary" id="confirm-location-btn" disabled>Load Forecast</button>
            </div>
        </div>
    </div>

    <!-- Dashboard Grid -->
    <div class="grid-stack" id="dashboard-grid">

        <!-- Current Conditions -->
        <div class="grid-stack-item" gs-x="0" gs-y="0" gs-w="4" gs-h="4">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Current Conditions</span>
                        <span class="panel-badge">Live</span>
                    </div>
                    <div class="panel-content" id="current-conditions-content">
                        <ul class="stat-list" id="current-conditions-stats">
                            <li class="stat-item">
                                <span class="stat-label">Wave Height</span>
                                <span class="stat-value" id="current_wave_height">- ft</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Wave Period</span>
                                <span class="stat-value" id="current_wave_period">- s</span>
                            </li>
                            <li class="stat-item">
                                <span class="stat-label">Wave Direction</span>
                                <span class="stat-value" id="current_wave_direction">- &deg;</span>
                            </li>
                        </ul>
                        <div class="chart-unavailable" id="current-conditions-error" style="display:none">Conditions data unavailable</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Surf Cam -->
        <div class="grid-stack-item" gs-x="4" gs-y="0" gs-w="4" gs-h="4">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Surf City Pier &mdash; Live Cam</span>
                        <span class="panel-badge">Live</span>
                    </div>
                    <div class="panel-content" style="padding: 0;">
                        <video id="surf-cam" style="width: 100%; display: block; background: #000;" muted autoplay playsinline></video>
                        <div id="surf-cam-error" style="display: none; padding: 8px; font-size: 11px; color: var(--status-error);">
                            Stream unavailable
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Surf Cam 2 -->
        <div class="grid-stack-item" gs-x="8" gs-y="0" gs-w="4" gs-h="4">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Topsail Beach &mdash; Live Cam</span>
                        <span class="panel-badge">Live</span>
                    </div>
                    <div class="panel-content" style="padding: 0;">
                        <video id="surf-cam-2" style="width: 100%; display: block; background: #000;" muted autoplay playsinline></video>
                        <div id="surf-cam-2-error" style="display: none; padding: 8px; font-size: 11px; color: var(--status-error);">
                            Stream unavailable
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Ocean Basin -->
        <div class="grid-stack-item" gs-x="0" gs-y="4" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Ocean Basin</span>
                        <div class="panel-header-actions">
                            <div class="basin-layer-menu">
                                <button class="basin-layer-btn" onclick="toggleBasinLayerMenu(event)">Layers &#9662;</button>
                                <div class="basin-layer-dropdown" id="basin-layer-dropdown">
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-height" checked onchange="onBasinLayerToggle('height')">
                                        Wave Height
                                    </label>
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-period" onchange="onBasinLayerToggle('period')">
                                        Wave Period
                                    </label>
                                    <label class="basin-layer-item">
                                        <input type="checkbox" id="basin-layer-wind" checked onchange="onBasinLayerToggle('wind')">
                                        Wind Animation
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="panel-content">
                        <div id="map-basin" class="map-container">
                            <div class="map-loading">Loading ocean data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Local Wave Height -->
        <div class="grid-stack-item" gs-x="0" gs-y="9" gs-w="4" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Local Wave Height (ft)</span>
                    </div>
                    <div class="panel-content">
                        <div id="map-wave-height" class="map-container">
                            <div class="map-loading">Loading map data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Local Wind Speed -->
        <div class="grid-stack-item" gs-x="4" gs-y="9" gs-w="4" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Local Wind Speed &amp; Direction</span>
                    </div>
                    <div class="panel-content">
                        <div id="map-wind" class="map-container">
                            <div class="map-loading">Loading map data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Local Wave Period -->
        <div class="grid-stack-item" gs-x="8" gs-y="9" gs-w="4" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Local Wave Period (s)</span>
                    </div>
                    <div class="panel-content">
                        <div id="map-wave-period" class="map-container">
                            <div class="map-loading">Loading map data...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Unified Map Time Slider -->
        <div class="grid-stack-item" gs-x="0" gs-y="14" gs-w="12" gs-h="1" gs-no-resize="true">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Map Time</span>
                        <span class="panel-badge" id="map-time-badge">Loading</span>
                    </div>
                    <div class="panel-content" style="padding: 0;">
                        <div class="slider-row">
                            <span class="slider-label" id="time-label">Time:</span>
                            <input type="range" class="slider-input" id="time-slider" min="0" max="0" step="1">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wave & Wind Chart -->
        <div class="grid-stack-item" gs-x="0" gs-y="15" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Wave &amp; Wind Forecast</span>
                        <button class="chart-home-btn" id="wave-chart-reset" onclick="resetWaveChart()">Reset Zoom</button>
                    </div>
                    <div class="panel-content">
                        <div class="chart-wrap">
                            <canvas id="waveChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tidal Predictions -->
        <div class="grid-stack-item" gs-x="0" gs-y="20" gs-w="12" gs-h="5">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Tidal Predictions</span>
                        <button class="chart-home-btn" id="tide-chart-reset" onclick="resetTideChart()">Reset Zoom</button>
                        <span class="panel-badge" id="tide-station-info">Loading station</span>
                    </div>
                    <div class="panel-content">
                        <div class="chart-wrap">
                            <canvas id="tideChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Daylight Forecast -->
        <div class="grid-stack-item" gs-x="0" gs-y="25" gs-w="12" gs-h="6">
            <div class="grid-stack-item-content">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Daylight Forecast</span>
                    </div>
                    <div class="panel-content">
                        <p class="conditions-hint">
                            <span class="good">&#10003;</span> = Offshore/calm wind (NW &plusmn;45&deg; or &lt;3 mph) &mdash; good conditions
                        </p>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Waves (ft)</th>
                                    <th>Period (s)</th>
                                    <th>Wind (mph)</th>
                                    <th>Wind Dir</th>
                                </tr>
                            </thead>
                            <tbody id="forecast-table"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- JS Libraries (no Bootstrap JS) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-velocity@2.1.4/dist/leaflet-velocity.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <!-- GridStack JS -->
    <script src="https://cdn.jsdelivr.net/npm/gridstack@10/dist/gridstack-all.js"></script>

    <script>
        // === Share Link ===
        function copyShareLink() {
            navigator.clipboard.writeText('https://freesurfforecast.com').then(function() {
                const toast = document.getElementById('share-toast');
                toast.classList.add('show');
                setTimeout(function() { toast.classList.remove('show'); }, 2000);
            });
        }

        // === GridStack Init ===
        let dashboardGrid = null;

        document.addEventListener('DOMContentLoaded', function() {
            // Restore saved layout if available
            const savedLayout = localStorage.getItem('dashboard-layout');

            var isMobile = window.innerWidth <= 700;

            dashboardGrid = GridStack.init({
                cellHeight: 70,
                margin: 2,
                column: 12,
                float: false,
                handle: '.panel-header',
                oneColumnSize: 700,
                acceptWidgets: false,
                disableDrag: isMobile,
                disableResize: isMobile
            }, '#dashboard-grid');

            if (savedLayout) {
                try {
                    const items = JSON.parse(savedLayout);
                    dashboardGrid.load(items, false);
                } catch (e) {
                    console.warn('Failed to restore layout:', e);
                }
            }

            // Save layout on change
            dashboardGrid.on('change', function(event, items) {
                saveLayout();
                invalidateAllMapsAndCharts();
            });

            // Invalidate maps/charts after resize
            dashboardGrid.on('resizestop', function(event, el) {
                setTimeout(function() {
                    el.querySelectorAll('.map-container').forEach(function(container) {
                        const mapInstance = getMapById(container.id);
                        if (mapInstance) mapInstance.invalidateSize();
                    });
                    el.querySelectorAll('canvas').forEach(function(canvas) {
                        const chart = Chart.getChart(canvas);
                        if (chart) chart.resize();
                    });
                }, 100);
            });

            // Toggle drag/resize on window resize (e.g. phone rotation)
            window.addEventListener('resize', function() {
                var mobile = window.innerWidth <= 700;
                dashboardGrid.enableMove(!mobile);
                dashboardGrid.enableResize(!mobile);
            });
        });

        function saveLayout() {
            if (!dashboardGrid) return;
            const items = dashboardGrid.save(false);
            localStorage.setItem('dashboard-layout', JSON.stringify(items));
        }

        function invalidateAllMapsAndCharts() {
            setTimeout(function() {
                document.querySelectorAll('.map-container').forEach(function(container) {
                    const mapInstance = getMapById(container.id);
                    if (mapInstance) mapInstance.invalidateSize();
                });
                document.querySelectorAll('.chart-wrap canvas').forEach(function(canvas) {
                    const chart = Chart.getChart(canvas);
                    if (chart) chart.resize();
                });
            }, 100);
        }

        // === Panel Fullscreen ===
        function toggleFullscreen(btn) {
            const gsItem = btn.closest('.grid-stack-item');
            const isFullscreen = gsItem.classList.toggle('panel-fullscreen-wrapper');
            btn.textContent = isFullscreen ? '\u2716' : '\u26F6';
            btn.title = isFullscreen ? 'Exit fullscreen' : 'Fullscreen';

            // Disable/enable GridStack drag+resize while fullscreen
            if (dashboardGrid) {
                if (isFullscreen) {
                    dashboardGrid.movable(gsItem, false);
                    dashboardGrid.resizable(gsItem, false);
                } else {
                    dashboardGrid.movable(gsItem, true);
                    dashboardGrid.resizable(gsItem, true);
                }
            }

            // Invalidate Leaflet maps inside this widget
            setTimeout(function() {
                gsItem.querySelectorAll('.map-container').forEach(function(container) {
                    const mapId = container.id;
                    const mapInstance = getMapById(mapId);
                    if (mapInstance) mapInstance.invalidateSize();
                });
                // Resize Chart.js canvases
                gsItem.querySelectorAll('canvas').forEach(function(canvas) {
                    const chart = Chart.getChart(canvas);
                    if (chart) chart.resize();
                });
            }, 100);
        }

        function getMapById(id) {
            const mapLookup = {
                'map-basin': () => mapBasin,
                'map-wave-period': () => map1,
                'map-wave-height': () => map2,
                'map-wind': () => map3,
            };
            return mapLookup[id] ? mapLookup[id]() : null;
        }

        // Inject fullscreen buttons into all panel headers
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.grid-stack-item-content .panel > .panel-header').forEach(function(header) {
                // Wrap existing badge(s) and add fullscreen button
                const actions = document.createElement('div');
                actions.className = 'panel-header-actions';

                // Move existing badges into actions container
                header.querySelectorAll('.panel-badge').forEach(function(badge) {
                    actions.appendChild(badge);
                });

                const btn = document.createElement('button');
                btn.className = 'panel-btn';
                btn.textContent = '\u26F6';
                btn.title = 'Fullscreen';
                btn.onclick = function() { toggleFullscreen(this); };
                actions.appendChild(btn);

                header.appendChild(actions);
            });
        });

        // ESC to exit fullscreen
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const fs = document.querySelector('.panel-fullscreen-wrapper');
                if (fs) {
                    const btn = fs.querySelector('.panel-btn');
                    if (btn) toggleFullscreen(btn);
                }
            }
        });

        // === Page Fullscreen ===
        function togglePageFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        document.addEventListener('fullscreenchange', function() {
            const btn = document.getElementById('page-fullscreen-btn');
            btn.textContent = document.fullscreenElement ? '\u2716' : '\u26F6';
            btn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Fullscreen';
        });

        // === Unit Conversions ===
        const M_TO_FT = 3.28084;
        const KMH_TO_MPH = 0.621371;
        const KM_TO_MI = 0.621371;

        // === Unified Map Data Globals ===
        let basinGridData = null;
        let localGridData = null;

        // === Ocean Canvas Clipping ===
        // Clip grid data to ocean using the coastline GeoJSON as a canvas clip path.
        // Grid cells are drawn on a canvas, clipped to the ocean shape â€” no mask layer needed,
        // no alignment issues, Windy-style sharp coastline boundary.
        let landPolygons = [];

        fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-10m.json')
            .then(r => r.json())
            .then(topo => {
                const geojson = topojson.feature(topo, topo.objects.land);
                geojson.features.forEach(feature => {
                    const coords = feature.geometry.coordinates;
                    if (feature.geometry.type === 'Polygon') {
                        landPolygons.push(coords[0]);
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        coords.forEach(poly => landPolygons.push(poly[0]));
                    }
                });
                landPolygons = landPolygons.map(ring => {
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    ring.forEach(([x, y]) => {
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                    });
                    return { ring, bbox: [minX, minY, maxX, maxY] };
                });
                console.log(`Loaded ${landPolygons.length} land polygons for ocean clipping`);
            })
            .catch(err => console.warn('Land TopoJSON fetch failed:', err));

        // Patch L.Canvas renderer to clip drawing to ocean when oceanClip option is set
        const _origCanvasDraw = L.Canvas.prototype._draw;
        L.Canvas.prototype._draw = function() {
            if (this.options.oceanClip && landPolygons.length && this._map) {
                const ctx = this._ctx;
                const map = this._map;
                const mapBounds = map.getBounds();

                ctx.save();
                ctx.beginPath();
                ctx.rect(-1e7, -1e7, 2e7, 2e7);

                for (const { ring, bbox } of landPolygons) {
                    if (bbox[2] < mapBounds.getWest() || bbox[0] > mapBounds.getEast() ||
                        bbox[3] < mapBounds.getSouth() || bbox[1] > mapBounds.getNorth()) continue;
                    let first = true;
                    for (const [lon, lat] of ring) {
                        const p = map.latLngToLayerPoint([lat, lon]);
                        if (first) { ctx.moveTo(p.x, p.y); first = false; }
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.closePath();
                }
                ctx.clip('evenodd');
            }
            _origCanvasDraw.call(this);
            if (this.options.oceanClip && landPolygons.length && this._map) {
                this._ctx.restore();
            }
        };

        function addMapDataError(map, message) {
            const ctrl = L.control({ position: 'topright' });
            ctrl.onAdd = function() {
                const div = L.DomUtil.create('div', 'map-data-error');
                div.textContent = message;
                return div;
            };
            ctrl.addTo(map);
        }

        function showChartUnavailable(canvasId, message) {
            const canvas = document.getElementById(canvasId);
            const wrap = canvas.parentElement;
            canvas.style.display = 'none';
            let overlay = wrap.querySelector('.chart-unavailable');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'chart-unavailable';
                wrap.appendChild(overlay);
            }
            overlay.textContent = message;
        }

        function clearChartUnavailable(canvasId) {
            const canvas = document.getElementById(canvasId);
            const wrap = canvas.parentElement;
            canvas.style.display = '';
            const overlay = wrap.querySelector('.chart-unavailable');
            if (overlay) overlay.remove();
        }

        function initEmptyMap(containerId, center, zoom, errorMessage) {
            const el = document.getElementById(containerId);
            el.innerHTML = '';
            const map = L.map(containerId).setView(center, zoom);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                maxZoom: 19
            }).addTo(map);
            addHomeButton(map, center, zoom);
            addMapDataError(map, errorMessage);
            setTimeout(() => map.invalidateSize(), 100);
            return map;
        }

        // === Shared Time Axis ===
        let waveTimeRange = null;   // { min: Date, max: Date }
        let tideTimeRange = null;
        function syncChartTimeAxes() {
            if (!waveTimeRange || !tideTimeRange) return;
            // Use the intersection so both charts cover the same time window
            const sharedMin = new Date(Math.max(waveTimeRange.min, tideTimeRange.min));
            const sharedMax = new Date(Math.min(waveTimeRange.max, tideTimeRange.max));
            if (waveChart && waveChart.canvas) {
                waveChart.options.scales.x.min = sharedMin;
                waveChart.options.scales.x.max = sharedMax;
                waveChart.update('none');
            }
            if (tideChart && tideChart.canvas) {
                tideChart.options.scales.x.min = sharedMin;
                tideChart.options.scales.x.max = sharedMax;
                tideChart.update('none');
            }
        }

        function resetWaveChart() {
            if (waveChart) {
                waveChart.resetZoom();
                syncChartTimeAxes();
            }
            document.getElementById('wave-chart-reset').style.display = 'none';
        }

        function resetTideChart() {
            if (tideChart) {
                tideChart.resetZoom();
                syncChartTimeAxes();
            }
            document.getElementById('tide-chart-reset').style.display = 'none';
        }

        // === Live Clock ===
        function updateClock() {
            const now = new Date();
            const h = String(now.getHours()).padStart(2, '0');
            const m = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('header-clock').textContent = h + ':' + m + ':' + s;
        }
        setInterval(updateClock, 1000);
        updateClock();

        // === Map Home Button Control ===
        function addHomeButton(map, center, zoom) {
            const HomeControl = L.Control.extend({
                options: { position: 'topleft' },
                onAdd: function() {
                    const btn = L.DomUtil.create('div', 'map-home-btn');
                    btn.innerHTML = '&#8962;';
                    btn.title = 'Reset view';
                    L.DomEvent.disableClickPropagation(btn);
                    L.DomEvent.on(btn, 'click', function() {
                        map.setView(center, zoom);
                    });
                    return btn;
                }
            });
            map.addControl(new HomeControl());
        }

        // === Custom Modal ===
        function openModal() {
            const modal = document.getElementById('locationModal');
            modal.classList.add('open');
            // Initialize or refresh the Leaflet map
            setTimeout(function() {
                if (!locationMap) {
                    initLocationMap();
                } else {
                    locationMap.invalidateSize();
                }
            }, 100);
        }

        function closeModal() {
            document.getElementById('locationModal').classList.remove('open');
        }

        // Close modal on overlay click (but not on card click)
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('locationModal');
            if (e.target === modal) {
                closeModal();
            }
        });

        // === Global location state ===
        let currentLocation = {
            lat: 34.42711,
            lon: -77.54608,
            name: 'Surf City, North Carolina'
        };
        let selectedLocation = null;
        let locationMap = null;
        let locationMarker = null;

        // Location selector map initialization
        function initLocationMap() {
            locationMap = L.map('location-map').setView([20, 0], 2);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                maxZoom: 19
            }).addTo(locationMap);

            // Add click handler
            locationMap.on('click', function(e) {
                const lat = e.latlng.lat;
                const lon = e.latlng.lng;

                // Remove existing marker
                if (locationMarker) {
                    locationMap.removeLayer(locationMarker);
                }

                // Add new marker
                locationMarker = L.marker([lat, lon]).addTo(locationMap);

                selectedLocation = { lat: lat, lon: lon };
                document.getElementById('confirm-location-btn').disabled = false;

                // Reverse geocode to get location name
                fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`)
                    .then(response => response.json())
                    .then(data => {
                        let name = 'Unknown Location';
                        if (data.address) {
                            const addr = data.address;
                            const parts = [];
                            if (addr.city) parts.push(addr.city);
                            else if (addr.town) parts.push(addr.town);
                            else if (addr.village) parts.push(addr.village);
                            else if (addr.county) parts.push(addr.county);

                            if (addr.state) parts.push(addr.state);
                            else if (addr.region) parts.push(addr.region);

                            if (addr.country) parts.push(addr.country);

                            if (parts.length > 0) {
                                name = parts.join(', ');
                            } else if (data.display_name) {
                                name = data.display_name.split(',').slice(0, 3).join(',');
                            }
                        }
                        selectedLocation.name = name;
                        document.getElementById('selected-location-text').textContent = `${name} (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
                    })
                    .catch(() => {
                        selectedLocation.name = `Location (${lat.toFixed(2)}, ${lon.toFixed(2)})`;
                        document.getElementById('selected-location-text').textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                    });
            });
        }

        // Confirm location button
        document.addEventListener('DOMContentLoaded', function() {
            const confirmBtn = document.getElementById('confirm-location-btn');

            confirmBtn.addEventListener('click', function() {
                if (selectedLocation) {
                    currentLocation = { ...selectedLocation };

                    // Update display
                    document.getElementById('location-name').textContent = currentLocation.name;
                    document.getElementById('display-lat').textContent = currentLocation.lat.toFixed(2);
                    document.getElementById('display-lon').textContent = currentLocation.lon.toFixed(2);

                    // Close modal
                    closeModal();

                    // Reload all data
                    reloadAllData();
                }
            });
        });

        // Function to reload all dashboard data
        function reloadAllData() {
            // Reset shared time ranges and map data
            waveTimeRange = null;
            tideTimeRange = null;
            basinGridData = null;
            localGridData = null;
            // Show loading state
            document.querySelectorAll('.map-container').forEach(el => {
                el.innerHTML = '<div class="map-loading">Loading data for new location...</div>';
            });

            // Reload point forecast and charts
            loadPointForecast();
            // Reload ocean basin maps
            loadOceanBasinMaps();
            // Reload local maps
            loadLocalMaps();
            // Reload tide data
            loadTideData();
        }

        // Point data and main chart script
        let waveChart = null;

        function loadPointForecast() {
            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            fetch(`/api/forecast?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('API Error (Point Data):', data.error);
                        showChartUnavailable('waveChart', 'Forecast data unavailable');
                        document.getElementById('current-conditions-stats').style.display = 'none';
                        document.getElementById('current-conditions-error').style.display = '';
                        return;
                    }
                    clearChartUnavailable('waveChart');
                    document.getElementById('current-conditions-stats').style.display = '';
                    document.getElementById('current-conditions-error').style.display = 'none';
                    const current = data[0];
                    document.getElementById('current_wave_height').textContent = `${(current.wave_height * M_TO_FT).toFixed(1)} ft`;
                    document.getElementById('current_wave_period').textContent = `${current.wave_period.toFixed(2)} s`;
                    document.getElementById('current_wave_direction').textContent = `${current.wave_direction.toFixed(0)} Â°`;
                    const tableBody = document.getElementById('forecast-table');
                    tableBody.innerHTML = '';

                    // Helper to convert wind direction to compass
                    function degToCompass(deg) {
                        if (deg === null || deg === undefined) return '-';
                        const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                        return dirs[Math.round(deg / 22.5) % 16];
                    }

                    // Check if wind is offshore (good for surfing)
                    const OFFSHORE_DIRECTION = 315;
                    const OFFSHORE_TOLERANCE = 45;
                    const CALM_WIND_THRESHOLD = 5;

                    function isOffshoreWind(windDirection, windSpeed) {
                        if (windSpeed !== null && windSpeed < CALM_WIND_THRESHOLD) {
                            return true;
                        }

                        if (windDirection === null || windDirection === undefined) {
                            return false;
                        }

                        let diff = Math.abs(windDirection - OFFSHORE_DIRECTION);
                        if (diff > 180) diff = 360 - diff;

                        return diff <= OFFSHORE_TOLERANCE;
                    }

                    // Filter to 5am-9pm and sample every 3 hours
                    let lastShownHour = -999;
                    data.forEach((item, index) => {
                        const itemTime = new Date(item.time);
                        const hour = itemTime.getHours();

                        if (hour < 5 || hour > 21) {
                            return;
                        }

                        if (hour % 3 !== 0) {
                            return;
                        }

                        const dayHourKey = itemTime.toDateString() + '-' + hour;
                        if (lastShownHour === dayHourKey) {
                            return;
                        }
                        lastShownHour = dayHourKey;

                        const dateStr = itemTime.toLocaleDateString([], {weekday: 'short', month: 'short', day: 'numeric'});
                        const timeStr = itemTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: true});
                        const windDir = item.wind_direction !== null ? `${degToCompass(item.wind_direction)} (${item.wind_direction.toFixed(0)}Â°)` : '-';
                        const windSpeed = item.wind_speed !== null ? (item.wind_speed * KMH_TO_MPH).toFixed(1) : '-';

                        const offshore = isOffshoreWind(item.wind_direction, item.wind_speed);
                        const rowClass = offshore ? 'row-good' : '';
                        const offshoreIndicator = offshore ? ' &#10003;' : '';

                        const row = `<tr class="${rowClass}">
                            <td>${dateStr}</td>
                            <td>${timeStr}</td>
                            <td>${(item.wave_height * M_TO_FT).toFixed(1)}</td>
                            <td>${item.wave_period.toFixed(1)}</td>
                            <td>${windSpeed}</td>
                            <td>${windDir}${offshoreIndicator}</td>
                        </tr>`;
                        tableBody.innerHTML += row;
                    });
                    const ctx = document.getElementById('waveChart').getContext('2d');

                    // Store wind directions for the custom plugin
                    const windDirections = data.map(item => item.wind_direction);

                    // Custom plugin to draw wind direction arrows
                    const windArrowPlugin = {
                        id: 'windArrows',
                        afterDatasetsDraw(chart) {
                            const meta = chart.getDatasetMeta(2);
                            if (!meta.visible) return;

                            const ctx = chart.ctx;
                            meta.data.forEach((point, index) => {
                                const direction = windDirections[index];
                                if (direction === null || direction === undefined) return;

                                const x = point.x;
                                const y = point.y;
                                const size = 8;

                                const radians = ((direction + 180) % 360) * Math.PI / 180;

                                ctx.save();
                                ctx.translate(x, y);
                                ctx.rotate(radians);

                                ctx.beginPath();
                                ctx.moveTo(0, -size);
                                ctx.lineTo(-size * 0.5, size * 0.5);
                                ctx.lineTo(0, size * 0.2);
                                ctx.lineTo(size * 0.5, size * 0.5);
                                ctx.closePath();

                                ctx.fillStyle = 'rgba(255, 206, 86, 0.9)';
                                ctx.fill();
                                ctx.strokeStyle = 'rgba(200, 160, 60, 1)';
                                ctx.lineWidth = 1;
                                ctx.stroke();

                                ctx.restore();
                            });
                        }
                    };

                    // Destroy existing chart if it exists
                    // Compute time range for sync
                    const waveTimes = data.map(item => new Date(item.time));
                    waveTimeRange = { min: waveTimes[0], max: waveTimes[waveTimes.length - 1] };

                    if (waveChart) {
                        waveChart.destroy();
                    }

                    waveChart = new Chart(ctx, {
                        type: 'line',
                        plugins: [windArrowPlugin],
                        data: {
                            datasets: [
                                {
                                    label: 'Total Wave Height (ft)',
                                    data: data.map(item => ({ x: new Date(item.time), y: item.wave_height * M_TO_FT })),
                                    borderColor: 'rgb(75, 192, 192)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    tension: 0.1,
                                    yAxisID: 'y',
                                    pointRadius: 2
                                },
                                {
                                    label: 'Wind Wave Height (ft)',
                                    data: data.map(item => ({ x: new Date(item.time), y: item.wind_wave_height * M_TO_FT })),
                                    borderColor: 'rgb(255, 99, 132)',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    tension: 0.1,
                                    yAxisID: 'y',
                                    pointRadius: 2
                                },
                                {
                                    label: 'Wind Speed (mph)',
                                    data: data.map(item => ({ x: new Date(item.time), y: item.wind_speed * KMH_TO_MPH })),
                                    borderColor: 'rgb(255, 206, 86)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    tension: 0.1,
                                    yAxisID: 'y1',
                                    pointRadius: 0,
                                    borderWidth: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            hour: 'MMM d HH:mm'
                                        },
                                        tooltipFormat: 'MMM d, yyyy HH:mm'
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 45,
                                        autoSkip: true,
                                        maxTicksLimit: 24,
                                        color: '#888'
                                    },
                                    grid: {
                                        color: 'rgba(42, 42, 42, 0.8)'
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    position: 'left',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Wave Height (ft)',
                                        color: 'rgb(75, 192, 192)'
                                    },
                                    ticks: {
                                        color: 'rgb(75, 192, 192)'
                                    },
                                    grid: {
                                        color: 'rgba(75, 192, 192, 0.15)'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    position: 'right',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Wind Speed (mph)',
                                        color: 'rgb(255, 206, 86)'
                                    },
                                    ticks: {
                                        color: 'rgb(255, 206, 86)'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    labels: { color: '#888' }
                                },
                                tooltip: {
                                    callbacks: {
                                        afterBody: function(context) {
                                            const index = context[0].dataIndex;
                                            const dir = windDirections[index];
                                            if (dir !== null && dir !== undefined) {
                                                return `Wind Direction: ${dir.toFixed(0)}Â°`;
                                            }
                                            return '';
                                        }
                                    }
                                },
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x'
                                    },
                                    zoom: {
                                        wheel: { enabled: true },
                                        pinch: { enabled: true },
                                        mode: 'x',
                                        onZoomComplete: () => document.getElementById('wave-chart-reset').style.display = ''
                                    }
                                }
                            }
                        }
                    });

                    syncChartTimeAxes();
                })
                .catch(error => {
                    console.error('Error fetching point forecast data:', error);
                    showChartUnavailable('waveChart', 'Forecast data unavailable');
                    document.getElementById('current-conditions-stats').style.display = 'none';
                    document.getElementById('current-conditions-error').style.display = '';
                });
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', function() {
            loadPointForecast();
        });

        // Ocean Basin map script
        let mapBasin = null;
        let basinGridLayer = null;
        let basinVelocityLayer = null;
        let basinLegendControl = null;

        // Basin layer dropdown menu
        function toggleBasinLayerMenu(e) {
            e.stopPropagation();
            const dropdown = document.getElementById('basin-layer-dropdown');
            dropdown.classList.toggle('open');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('basin-layer-dropdown');
            if (dropdown && !e.target.closest('.basin-layer-menu')) {
                dropdown.classList.remove('open');
            }
        });

        function getBasinLayerState() {
            return {
                height: document.getElementById('basin-layer-height').checked,
                period: document.getElementById('basin-layer-period').checked,
                wind: document.getElementById('basin-layer-wind').checked
            };
        }

        function onBasinLayerToggle(source) {
            const heightCb = document.getElementById('basin-layer-height');
            const periodCb = document.getElementById('basin-layer-period');

            // Wave height and wave period are mutually exclusive
            if (source === 'height' && heightCb.checked) {
                periodCb.checked = false;
            } else if (source === 'period' && periodCb.checked) {
                heightCb.checked = false;
            }

            // Re-render with current slider time
            const slider = document.getElementById('time-slider');
            const timeIndex = parseInt(slider.value) || 0;
            updateBasinMap(timeIndex);
        }

        function updateBasinLegend() {
            if (!mapBasin) return;
            if (basinLegendControl) {
                mapBasin.removeControl(basinLegendControl);
                basinLegendControl = null;
            }
            const state = getBasinLayerState();
            // Show legend for whichever grid layer is active (height takes priority if both)
            let title, minVal, maxVal;
            if (state.height) {
                title = 'Height (ft)'; minVal = 0; maxVal = 20;
            } else if (state.period) {
                title = 'Period (s)'; minVal = 0; maxVal = 15;
            } else {
                return; // No grid layer active
            }
            basinLegendControl = L.control({position: 'bottomright'});
            basinLegendControl.onAdd = function() {
                const div = L.DomUtil.create('div', 'legend');
                const colors = ['blue', 'cyan', 'lime', 'yellow', 'red'];
                div.innerHTML = `<strong>${title}</strong><br>`;
                colors.forEach((color, i) => {
                    const val = minVal + (maxVal - minVal) * i / (colors.length - 1);
                    div.innerHTML += `<span class="legend-color" style="background:${color}"></span>${val.toFixed(1)}<br>`;
                });
                return div;
            };
            basinLegendControl.addTo(mapBasin);
        }

        function buildVelocityData(timeIndex) {
            if (!basinGridData || !basinGridData.wind_speed) return null;
            const lats = basinGridData.lats;
            const lons = basinGridData.lons;
            const bTimeIndex = Math.min(timeIndex, basinGridData.times.length - 1);
            const nx = lons.length;
            const ny = lats.length;
            const lo1 = lons[0];
            const lo2 = lons[lons.length - 1];
            const la1 = lats[lats.length - 1]; // north (data north-to-south for velocity)
            const la2 = lats[0]; // south
            const dx = lons.length > 1 ? Math.abs(lons[1] - lons[0]) : 1.5;
            const dy = lats.length > 1 ? Math.abs(lats[1] - lats[0]) : 1.5;

            const uData = [];
            const vData = [];
            // leaflet-velocity expects north-to-south row order; our lats are south-to-north
            for (let i = lats.length - 1; i >= 0; i--) {
                for (let j = 0; j < lons.length; j++) {
                    const speedKmh = basinGridData.wind_speed[bTimeIndex][i][j];
                    const dir = basinGridData.wind_direction[bTimeIndex][i][j];
                    const speedMs = speedKmh / 3.6;
                    const dirRad = dir * Math.PI / 180;
                    uData.push(-speedMs * Math.sin(dirRad));
                    vData.push(-speedMs * Math.cos(dirRad));
                }
            }

            const header = {
                parameterCategory: 2,
                parameterNumber: 2,
                lo1: lo1, lo2: lo2, la1: la1, la2: la2,
                dx: dx, dy: dy, nx: nx, ny: ny
            };

            return [
                { header: Object.assign({}, header, { parameterNumber: 2 }), data: uData },
                { header: Object.assign({}, header, { parameterNumber: 3 }), data: vData }
            ];
        }

        function updateBasinVelocityLayer(timeIndex) {
            if (!mapBasin) return;
            const state = getBasinLayerState();

            if (!state.wind) {
                if (basinVelocityLayer) {
                    mapBasin.removeLayer(basinVelocityLayer);
                    basinVelocityLayer = null;
                }
                return;
            }

            const velocityData = buildVelocityData(timeIndex);
            if (!velocityData) return;

            if (basinVelocityLayer) {
                basinVelocityLayer.setData(velocityData);
            } else {
                basinVelocityLayer = L.velocityLayer({
                    displayValues: true,
                    displayOptions: {
                        velocityType: 'Wind',
                        displayPosition: 'bottomleft',
                        displayEmptyString: 'No wind data'
                    },
                    data: velocityData,
                    maxVelocity: 25,
                    velocityScale: 0.01,
                    particleAge: 60,
                    lineWidth: 1.5,
                    particleMultiplier: 1/200,
                    colorScale: [
                        'rgba(255,255,255,0.2)',
                        'rgba(255,255,255,0.35)',
                        'rgba(255,255,255,0.5)',
                        'rgba(200,200,255,0.6)',
                        'rgba(150,200,255,0.7)',
                        'rgba(100,180,255,0.8)'
                    ]
                });
                basinVelocityLayer.addTo(mapBasin);
            }
        }

        function updateBasinMap(timeIndex) {
            if (!basinGridData || !mapBasin) return;

            const state = getBasinLayerState();

            // Update grid layer
            if (basinGridLayer) {
                mapBasin.removeLayer(basinGridLayer);
                basinGridLayer = null;
            }

            if (state.height || state.period) {
                basinGridLayer = L.layerGroup();
                const basinRenderer = L.canvas({ padding: 0.5, oceanClip: true });

                const bLats = basinGridData.lats;
                const bLons = basinGridData.lons;
                const basinRes = bLats.length > 1 ? Math.abs(bLats[1] - bLats[0]) : 6;
                const bHalfRes = basinRes / 2;
                const bTimeIndex = Math.min(timeIndex, basinGridData.times.length - 1);

                for (let i = 0; i < bLats.length; i++) {
                    for (let j = 0; j < bLons.length; j++) {
                        const lat = bLats[i];
                        const lon = bLons[j];
                        const bounds = [[lat - bHalfRes, lon - bHalfRes], [lat + bHalfRes, lon + bHalfRes]];

                        if (state.height) {
                            const wh = basinGridData.wave_height[bTimeIndex][i][j];
                            if (wh > 0) {
                                const color = getColorForValue(wh, 0, 6);
                                L.rectangle(bounds, {
                                    renderer: basinRenderer, color: color, weight: 0, fillColor: color, fillOpacity: 0.7
                                }).bindPopup(`Wave Height: ${(wh * M_TO_FT).toFixed(1)} ft`).addTo(basinGridLayer);
                            }
                        } else if (state.period) {
                            const wp = basinGridData.wave_period[bTimeIndex][i][j];
                            if (wp > 0) {
                                const color = getColorForValue(wp, 0, 15);
                                L.rectangle(bounds, {
                                    renderer: basinRenderer, color: color, weight: 0, fillColor: color, fillOpacity: 0.7
                                }).bindPopup(`Wave Period: ${wp.toFixed(1)} s`).addTo(basinGridLayer);
                            }
                        }
                    }
                }

                basinGridLayer.addTo(mapBasin);
            }

            // Update legend
            updateBasinLegend();

            // Update velocity layer
            updateBasinVelocityLayer(timeIndex);
        }

        function loadOceanBasinMaps() {
            // Clear existing map
            if (mapBasin) {
                mapBasin.remove();
                mapBasin = null;
            }
            basinGridLayer = null;
            basinVelocityLayer = null;
            basinLegendControl = null;

            // Reset container HTML
            document.getElementById('map-basin').innerHTML = '<div class="map-loading">Loading ocean data...</div>';

            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            fetch(`/api/ocean-basin?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('API Error (Basin Data):', data.error);
                        const center = [currentLocation.lat, currentLocation.lon];
                        mapBasin = initEmptyMap('map-basin', center, 4, 'Ocean data unavailable');
                        return;
                    }

                    // Store data globally
                    basinGridData = data;

                    const center = data.center;

                    // Clear loading message
                    document.getElementById('map-basin').innerHTML = '';

                    // Initialize map centered on the forecast location
                    mapBasin = L.map('map-basin').setView([center.lat, center.lon], 4);

                    addHomeButton(mapBasin, [center.lat, center.lon], 4);

                    const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
                    const tileLayerOptions = {
                        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                        maxZoom: 10
                    };

                    L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(mapBasin);

                    // Add marker for forecast location
                    const locationIcon = L.divIcon({
                        html: '<div style="color: #ff0; font-size: 20px; text-shadow: 2px 2px 4px black;">&#9733;</div>',
                        className: 'location-marker',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    L.marker([center.lat, center.lon], {icon: locationIcon}).addTo(mapBasin).bindPopup(currentLocation.name);

                    setTimeout(() => {
                        mapBasin.invalidateSize();
                    }, 100);

                    // Notify unified slider
                    onMapDataReady();
                })
                .catch(error => {
                    console.error('Error fetching ocean basin data:', error);
                    const center = [currentLocation.lat, currentLocation.lon];
                    mapBasin = initEmptyMap('map-basin', center, 4, 'Ocean data unavailable');
                });
        }

        // Initial load for basin maps
        document.addEventListener('DOMContentLoaded', function() {
            loadOceanBasinMaps();
        });

        // Local map data and animation script
        let map1 = null, map2 = null, map3 = null;
        let localWavePeriodLayer = null, localWaveHeightLayer = null, localWindLayer = null;

        function loadLocalMaps() {
            const mapContainers = ['map-wave-period', 'map-wave-height', 'map-wind'];

            // Clear existing maps
            if (map1) { map1.remove(); map1 = null; }
            if (map2) { map2.remove(); map2 = null; }
            if (map3) { map3.remove(); map3 = null; }
            localWavePeriodLayer = null;
            localWaveHeightLayer = null;
            localWindLayer = null;

            // Reset container HTML
            mapContainers.forEach(id => {
                document.getElementById(id).innerHTML = '<div class="map-loading">Loading map data...</div>';
            });

            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            fetch(`/api/map-forecast?${params}`)
                .then(response => response.json())
                .then(gridData => {
                    if (gridData.error) {
                        console.error('API Error (Map Data):', gridData.error);
                        const center = [currentLocation.lat, currentLocation.lon];
                        map1 = initEmptyMap('map-wave-period', center, 8, 'Forecast data unavailable');
                        map2 = initEmptyMap('map-wave-height', center, 8, 'Forecast data unavailable');
                        map3 = initEmptyMap('map-wind', center, 8, 'Forecast data unavailable');
                        return;
                    }

                    if (!gridData.lats || !gridData.lons || !gridData.times || !gridData.wave_height || !gridData.wave_period || !gridData.wind_speed || !gridData.wind_direction) {
                        console.error("Invalid gridData structure:", gridData);
                        const center = [currentLocation.lat, currentLocation.lon];
                        map1 = initEmptyMap('map-wave-period', center, 8, 'Invalid data structure');
                        map2 = initEmptyMap('map-wave-height', center, 8, 'Invalid data structure');
                        map3 = initEmptyMap('map-wind', center, 8, 'Invalid data structure');
                        return;
                    }

                    // Store data globally
                    localGridData = gridData;

                    const lats = gridData.lats;
                    const lons = gridData.lons;

                    const centerLat = (lats[0] + lats[lats.length - 1]) / 2;
                    const centerLon = (lons[0] + lons[lons.length - 1]) / 2;

                    // Clear loading messages
                    mapContainers.forEach(id => {
                        document.getElementById(id).innerHTML = '';
                    });

                    // Initialize maps
                    map1 = L.map('map-wave-period').setView([centerLat, centerLon], 8);
                    map2 = L.map('map-wave-height').setView([centerLat, centerLon], 8);
                    map3 = L.map('map-wind').setView([centerLat, centerLon], 8);

                    addHomeButton(map1, [centerLat, centerLon], 8);
                    addHomeButton(map2, [centerLat, centerLon], 8);
                    addHomeButton(map3, [centerLat, centerLon], 8);

                    const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
                    const tileLayerOptions = {
                        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
                        maxZoom: 19
                    };

                    L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map1);
                    L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map2);
                    L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map3);

                    setTimeout(() => {
                        map1.invalidateSize();
                        map2.invalidateSize();
                        map3.invalidateSize();
                    }, 100);

                    // Add legends
                    function addLegend(map, title, minVal, maxVal, colors) {
                        const legend = L.control({position: 'bottomright'});
                        legend.onAdd = function() {
                            const div = L.DomUtil.create('div', 'legend');
                            div.innerHTML = `<strong>${title}</strong><br>`;
                            colors.forEach((color, i) => {
                                const val = minVal + (maxVal - minVal) * i / (colors.length - 1);
                                div.innerHTML += `<span class="legend-color" style="background:${color}"></span>${val.toFixed(1)}<br>`;
                            });
                            return div;
                        };
                        legend.addTo(map);
                    }

                    addLegend(map1, 'Period (s)', 0, 15, ['#00f', '#0ff', '#0f0', '#ff0', '#f00']);
                    addLegend(map2, 'Height (ft)', 0, 10, ['#00f', '#0ff', '#0f0', '#ff0', '#f00']);

                    // Wind legend
                    const windLegend = L.control({position: 'bottomright'});
                    windLegend.onAdd = function() {
                        const div = L.DomUtil.create('div', 'legend');
                        div.innerHTML = '<strong>Wind (mph)</strong><br>' +
                            '<span style="color:#33ff88">&rarr;</span> 0-6<br>' +
                            '<span style="color:#3388ff">&rarr;</span> 6-12<br>' +
                            '<span style="color:#ffff33">&rarr;</span> 12-19<br>' +
                            '<span style="color:#ff8833">&rarr;</span> 19+';
                        return div;
                    };
                    windLegend.addTo(map3);

                    // Notify unified slider
                    onMapDataReady();
                })
                .catch(error => {
                    console.error('Error fetching map forecast data:', error);
                    const center = [currentLocation.lat, currentLocation.lon];
                    map1 = initEmptyMap('map-wave-period', center, 8, 'Forecast data unavailable');
                    map2 = initEmptyMap('map-wave-height', center, 8, 'Forecast data unavailable');
                    map3 = initEmptyMap('map-wind', center, 8, 'Forecast data unavailable');
                });
        }

        // === Unified Map Time Slider Logic ===
        function getColorForValue(value, minVal, maxVal) {
            const ratio = Math.min(1, Math.max(0, (value - minVal) / (maxVal - minVal)));
            const stops = [
                {pos: 0, r: 0, g: 0, b: 255},
                {pos: 0.25, r: 0, g: 255, b: 255},
                {pos: 0.5, r: 0, g: 255, b: 0},
                {pos: 0.75, r: 255, g: 255, b: 0},
                {pos: 1, r: 255, g: 0, b: 0}
            ];

            let lower = stops[0], upper = stops[stops.length - 1];
            for (let i = 0; i < stops.length - 1; i++) {
                if (ratio >= stops[i].pos && ratio <= stops[i + 1].pos) {
                    lower = stops[i];
                    upper = stops[i + 1];
                    break;
                }
            }

            const range = upper.pos - lower.pos;
            const t = range === 0 ? 0 : (ratio - lower.pos) / range;
            const r = Math.round(lower.r + t * (upper.r - lower.r));
            const g = Math.round(lower.g + t * (upper.g - lower.g));
            const b = Math.round(lower.b + t * (upper.b - lower.b));

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getWindColor(speed) {
            if (speed < 10) return '#33ff88';
            if (speed < 20) return '#3388ff';
            if (speed < 30) return '#ffff33';
            return '#ff8833';
        }

        function onMapDataReady() {
            // Determine time array from whichever dataset is available
            const times = (localGridData && localGridData.times) || (basinGridData && basinGridData.times);
            if (!times) return;

            const slider = document.getElementById('time-slider');
            slider.max = times.length - 1;
            slider.value = 0;
            updateAllMaps(0);
        }

        function updateAllMaps(timeIndex) {
            // Determine time array
            const times = (localGridData && localGridData.times) || (basinGridData && basinGridData.times);
            if (!times) return;

            // Update time badge and label
            const timeStr = new Date(times[timeIndex]).toLocaleString();
            document.getElementById('map-time-badge').textContent = timeStr;
            document.getElementById('time-label').textContent = 'Time: ' + timeStr;

            // === Update basin map ===
            if (basinGridData && mapBasin) {
                updateBasinMap(timeIndex);
            }

            // === Update local maps ===
            if (localGridData && map1 && map2 && map3) {
                if (localWavePeriodLayer) map1.removeLayer(localWavePeriodLayer);
                if (localWaveHeightLayer) map2.removeLayer(localWaveHeightLayer);
                if (localWindLayer) map3.removeLayer(localWindLayer);

                localWavePeriodLayer = L.layerGroup();
                localWaveHeightLayer = L.layerGroup();
                localWindLayer = L.layerGroup();

                const localPeriodRenderer = L.canvas({ padding: 0.5, oceanClip: true });
                const localHeightRenderer = L.canvas({ padding: 0.5, oceanClip: true });

                const lLats = localGridData.lats;
                const lLons = localGridData.lons;
                const localRes = lLats.length > 1 ? Math.abs(lLats[1] - lLats[0]) : 0.25;
                const lHalfRes = localRes / 2;

                // Clamp timeIndex to local data range
                const lTimeIndex = Math.min(timeIndex, localGridData.times.length - 1);

                for (let i = 0; i < lLats.length; i++) {
                    for (let j = 0; j < lLons.length; j++) {
                        const period = localGridData.wave_period[lTimeIndex][i][j];
                        const height = localGridData.wave_height[lTimeIndex][i][j];
                        const lat = lLats[i];
                        const lon = lLons[j];
                        const bounds = [[lat - lHalfRes, lon - lHalfRes], [lat + lHalfRes, lon + lHalfRes]];

                        if (period > 0) {
                            const color = getColorForValue(period, 0, 12);
                            L.rectangle(bounds, {
                                renderer: localPeriodRenderer, color: color, weight: 0, fillColor: color, fillOpacity: 0.7
                            }).bindPopup(`Wave Period: ${period.toFixed(1)} s`).addTo(localWavePeriodLayer);
                        }
                        if (height > 0) {
                            const color = getColorForValue(height, 0, 3);
                            L.rectangle(bounds, {
                                renderer: localHeightRenderer, color: color, weight: 0, fillColor: color, fillOpacity: 0.7
                            }).bindPopup(`Wave Height: ${(height * M_TO_FT).toFixed(1)} ft`).addTo(localWaveHeightLayer);
                        }
                    }
                }

                localWavePeriodLayer.addTo(map1);
                localWaveHeightLayer.addTo(map2);

                // Wind arrows (every 5th point)
                const step = Math.max(1, Math.floor(lLats.length / 5));
                for (let i = 0; i < lLats.length; i += step) {
                    for (let j = 0; j < lLons.length; j += step) {
                        const speed = localGridData.wind_speed[lTimeIndex][i][j];
                        const direction = localGridData.wind_direction[lTimeIndex][i][j];

                        if (speed > 0) {
                            const color = getWindColor(speed);
                            const rotation = (direction + 180) % 360;

                            const arrowIcon = L.divIcon({
                                html: `<div style="transform: rotate(${rotation}deg); color: ${color}; font-size: 18px; text-shadow: 1px 1px 2px black;">&#10148;</div>`,
                                className: 'wind-arrow',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            });

                            const marker = L.marker([lLats[i], lLons[j]], {icon: arrowIcon});
                            marker.bindPopup(`Wind: ${(speed * KMH_TO_MPH).toFixed(1)} mph<br>Direction: ${direction.toFixed(0)}Â°`);
                            localWindLayer.addLayer(marker);
                        }
                    }
                }

                localWindLayer.addTo(map3);
            }
        }

        // Wire up the slider
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('time-slider').addEventListener('input', function(e) {
                updateAllMaps(parseInt(e.target.value));
            });
        });

        // Initial load for local maps
        document.addEventListener('DOMContentLoaded', function() {
            loadLocalMaps();
        });

        // Tide chart script
        let tideChart = null;

        function loadTideData() {
            const params = new URLSearchParams({
                lat: currentLocation.lat,
                lon: currentLocation.lon
            });

            fetch(`/api/tides?${params}`)
                .then(response => response.json())
                .then(tideData => {
                    if (tideData.error) {
                        console.error('API Error (Tide Data):', tideData.error);
                        showChartUnavailable('tideChart', 'Tide data unavailable');
                        document.getElementById('tide-station-info').textContent = 'Unavailable';
                        return;
                    }
                    clearChartUnavailable('tideChart');

                    const ctx = document.getElementById('tideChart').getContext('2d');

                    // Update station info display
                    if (tideData.station) {
                        const stationInfo = document.getElementById('tide-station-info');
                        stationInfo.textContent = `${tideData.station.name} â€” ${(tideData.station.distance_km * KM_TO_MI).toFixed(1)} mi`;
                    }

                    // Prepare hourly data as {x, y} points
                    const tideTimes = tideData.hourly.map(item => new Date(item.time));
                    tideTimeRange = { min: tideTimes[0], max: tideTimes[tideTimes.length - 1] };

                    const heightsData = tideData.hourly.map(item => ({
                        x: new Date(item.time), y: item.height * M_TO_FT
                    }));

                    // Prepare high/low annotations
                    const highLowPoints = tideData.high_low.map(item => {
                        const d = new Date(item.time);
                        return {
                            time: d,
                            height: item.height,
                            type: item.type,
                            label: item.type === 'H' ? 'High' : 'Low'
                        };
                    });

                    const highTides = [];
                    const lowTides = [];

                    tideData.hourly.forEach((item, index) => {
                        const itemTime = new Date(item.time).getTime();

                        const matchingHighLow = highLowPoints.find(hl =>
                            Math.abs(hl.time.getTime() - itemTime) < 30 * 60 * 1000
                        );

                        if (matchingHighLow) {
                            if (matchingHighLow.type === 'H') {
                                highTides.push({ x: new Date(item.time), y: item.height * M_TO_FT });
                                lowTides.push(null);
                            } else {
                                lowTides.push({ x: new Date(item.time), y: item.height * M_TO_FT });
                                highTides.push(null);
                            }
                        } else {
                            highTides.push(null);
                            lowTides.push(null);
                        }
                    });

                    // Destroy existing chart if it exists
                    if (tideChart) {
                        tideChart.destroy();
                    }

                    tideChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'Tide Height (ft)',
                                    data: heightsData,
                                    borderColor: 'rgb(54, 162, 235)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: true,
                                    tension: 0.4,
                                    pointRadius: 0,
                                    borderWidth: 2
                                },
                                {
                                    label: 'High Tide',
                                    data: highTides,
                                    borderColor: 'transparent',
                                    backgroundColor: 'rgb(255, 99, 132)',
                                    pointRadius: 8,
                                    pointStyle: 'triangle',
                                    showLine: false
                                },
                                {
                                    label: 'Low Tide',
                                    data: lowTides,
                                    borderColor: 'transparent',
                                    backgroundColor: 'rgb(75, 192, 192)',
                                    pointRadius: 8,
                                    pointStyle: 'rectRot',
                                    showLine: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            hour: 'MMM d HH:mm'
                                        },
                                        tooltipFormat: 'MMM d, yyyy HH:mm'
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 45,
                                        autoSkip: true,
                                        maxTicksLimit: 24,
                                        color: '#888'
                                    },
                                    grid: {
                                        color: 'rgba(42, 42, 42, 0.8)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Height above MLLW (ft)',
                                        color: 'rgb(54, 162, 235)'
                                    },
                                    ticks: {
                                        color: 'rgb(54, 162, 235)'
                                    },
                                    grid: {
                                        color: 'rgba(54, 162, 235, 0.15)'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    position: 'right',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Wind Speed (mph)',
                                        color: 'transparent'
                                    },
                                    ticks: {
                                        color: 'transparent'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    labels: { color: '#888' }
                                },
                                tooltip: {
                                    callbacks: {
                                        afterBody: function(context) {
                                            const index = context[0].dataIndex;
                                            if (highTides[index] !== null) return 'â–² High Tide';
                                            if (lowTides[index] !== null) return 'â–¼ Low Tide';
                                            return '';
                                        }
                                    }
                                },
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x'
                                    },
                                    zoom: {
                                        wheel: { enabled: true },
                                        pinch: { enabled: true },
                                        mode: 'x',
                                        onZoomComplete: () => document.getElementById('tide-chart-reset').style.display = ''
                                    }
                                }
                            }
                        }
                    });

                    syncChartTimeAxes();
                })
                .catch(error => {
                    console.error('Error fetching tide data:', error);
                    showChartUnavailable('tideChart', 'Tide data unavailable');
                    document.getElementById('tide-station-info').textContent = 'Unavailable';
                });
        }

        // Initial load for tide data
        document.addEventListener('DOMContentLoaded', function() {
            loadTideData();
        });

        // === Surf Cams (HLS) ===
        function initHlsStream(videoId, errorId, streamUrl) {
            const video = document.getElementById(videoId);
            const errorEl = document.getElementById(errorId);

            if (Hls.isSupported()) {
                const hls = new Hls();
                hls.loadSource(streamUrl);
                hls.attachMedia(video);
                hls.on(Hls.Events.ERROR, function(event, data) {
                    if (data.fatal) {
                        video.style.display = 'none';
                        errorEl.style.display = 'block';
                    }
                });
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = streamUrl;
            } else {
                video.style.display = 'none';
                errorEl.style.display = 'block';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initHlsStream('surf-cam', 'surf-cam-error', 'https://streams.surfchex.com:8443/live/sc1.stream/playlist.m3u8');
            initHlsStream('surf-cam-2', 'surf-cam-2-error', 'https://5a5f765a4fcc2.streamlock.net:1936/live/topsail.stream/playlist.m3u8');
        });
    </script>
</body>
</html>
